[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "Introduction\nWelcome/Bienvenido to the central repository for my thesis project, which casts a spotlight on the intersection of surface temperatures, environmental injustice, and tourism along the Southern Gran Canaria coastline. Focusing on the localities of Maspalomas and Playa del Inglés and using remote sensing data from 2023, this project queries how these mass tourism destinations are affected by and contribute to climate-related disparities.\nThis platform serves as a comprehensive archive of the data analysis undertaken for project. Much of this is completed using R and Python, working within a GIS framework for these languages. Through innovative methodologies, this project operationalises a variety of remote sensing data sources from the LandSat 8 satellite to explore the distribution of surface temperatures on a micro-climate scale, juxtaposing these findings against the backdrop of local environmental justice and urban inequality concerns.\n\n\nAbout me\nI am a 24 year old Master’s Student on the MSc Islands and Sustainability programme. This is an Eramus Mundus Master’s programme based in four locations across Europe. I have been studying at the Unviersity of Groningen and the University of Las Palmas de Gran Canaria. My specialisms include GIS, Urban Justice, Tourism Studies, and Remote Sensing.\n\n\n\n\n\n\n\nPreparing Data\nFor this analysis, I aim use the following input data covering and clipped to the study area of Maspalomas-Playa del Inglés.\n\nLST\nNDVI (normalised difference vegetation index)\nNDBI (normalised difference built-up index)\nNDWI (normalised difference water index)\nNDSI (normalised difference sand index)\nSurface Albedo\n\nWe will also use the following auxiliary data\n\nRoad Proximity (from OSM)\nProximity to Coast/Ocean\nElevation\n\n\n\nLibraries\nThis methodology will use the following R packages for data wrangling using data from July 24th 2023 (a day when both Sentinel and Landsat imagery coincides).\n\nThe tidyverse family of packages (Wickham et al. 2019), which includes\n\ndplyr for wrangling data (Wickham et al. 2023)\ntidyr for managing data sets (Wickham, Vaughan, and Girlich 2024)\nggplot2 for visualisations (Wickham 2016)\n\nThe terra package for handling raster data (Hijmans 2024)\nThe RColorBrewer package for colour scales (Neuwirth 2022)\nThe sf package for handling shapefile data (Pebesma and Bivand 2023)\nThe leaflet package for interactive visualisation (Cheng et al. 2023)\nThe osmdata package for extracting coastline data (Massicotte and South 2023)\nThe modelsummary package for outputting regression results (Arel-Bundock 2022)\nThe ggnewscale package for help with layered plots (Campitelli 2024)\n\n\n\n\n\n\nReferences\n\nArel-Bundock, Vincent. 2022. “Modelsummary: Data and Model Summaries in r” 103. https://doi.org/10.18637/jss.v103.i01.\n\n\nCampitelli, Elio. 2024. “Ggnewscale: Multiple Fill and Colour Scales in ’Ggplot2’.” https://CRAN.R-project.org/package=ggnewscale.\n\n\nCheng, Joe, Barret Schloerke, Bhaskar Karambelkar, and Yihui Xie. 2023. “Leaflet: Create Interactive Web Maps with the JavaScript ’Leaflet’ Library.” https://CRAN.R-project.org/package=leaflet.\n\n\nHijmans, Robert J. 2024. “Terra: Spatial Data Analysis.” https://CRAN.R-project.org/package=terra.\n\n\nMassicotte, Philippe, and Andy South. 2023. “Rnaturalearth: World Map Data from Natural Earth.” https://CRAN.R-project.org/package=rnaturalearth.\n\n\nNeuwirth, Erich. 2022. “RColorBrewer: ColorBrewer Palettes.” https://CRAN.R-project.org/package=RColorBrewer.\n\n\nPebesma, Edzer, and Roger Bivand. 2023. “Spatial Data Science: With Applications in r.” https://doi.org/10.1201/9780429459016.\n\n\nWickham, Hadley. 2016. “Ggplot2: Elegant Graphics for Data Analysis.” https://ggplot2.tidyverse.org.\n\n\nWickham, Hadley, Mara Averick, Jennifer Bryan, Winston Chang, Lucy D’Agostino McGowan, Romain François, Garrett Grolemund, et al. 2019. “Welcome to the Tidyverse” 4: 1686. https://doi.org/10.21105/joss.01686.\n\n\nWickham, Hadley, Romain François, Lionel Henry, Kirill Müller, and Davis Vaughan. 2023. “Dplyr: A Grammar of Data Manipulation.” https://CRAN.R-project.org/package=dplyr.\n\n\nWickham, Hadley, Davis Vaughan, and Maximilian Girlich. 2024. “Tidyr: Tidy Messy Data.” https://CRAN.R-project.org/package=tidyr."
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "Jody Holland Thesis",
    "section": "",
    "text": "Welcome/Bienvenido to the central repository for my thesis project, which casts a spotlight on the intersection of surface temperatures, environmental injustice, and tourism along the Southern Gran Canaria coastline. Focusing on the localities of Maspalomas and Playa del Inglés and using remote sensing data from 2023, this project queries how these mass tourism destinations are affected by and contribute to climate-related disparities.\nThis platform serves as a comprehensive archive of the data analysis undertaken for project. Much of this is completed using R and Python, working within a GIS framework for these languages. Through innovative methodologies, this project operationalises a variety of remote sensing data sources such as the LandSat 8 satellite and the Sentinel 2 unit to explore the distribution of surface temperatures on a micro-climate scale, juxtaposing these findings against the backdrop of local environmental justice and urban inequality concerns."
  },
  {
    "objectID": "lsmodelling.html",
    "href": "lsmodelling.html",
    "title": "LandSat 8 Modelling",
    "section": "",
    "text": "The first methodological step is to train a variety of models predicting LST using LandSat 8 at 30m resolution. This is in a similar process to Onačillová et al. (2022); Equere et al. (2021); Son et al. (2017); Karyati et al. (2022). In this modelling process we employ two families of modelling approaches:\n\nLinear Regression (Onačillová et al. 2022)\nNeural Networks (Equere et al. 2021)\n\nThrough comparing the accuracy of these models we make inferences on which is most likely to provide high utility data for use in modelling 10m resolution LST with Sentinel 2 data as an input.\n\n\nThis methodology will use the following r packages for data wrangling using data from July 24th 2023 (a day when both Sentinel and Landsat imagery coincides).\n\nThe tidyverse family of packages (Wickham et al. 2019), which includes\n\ndplyr for wrangling data (Wickham et al. 2023)\ntidyr for managing data sets (Wickham, Vaughan, and Girlich 2024)\nggplot2 for visualisations (Wickham 2016)\n\nThe terra package for handling raster data (Hijmans 2024)\nThe RColorBrewer package for colour scales (Neuwirth 2022)\nThe sf package for handling shapefile data (Pebesma and Bivand 2023)\nThe leaflet package for interactive visualisation (Cheng et al. 2023)\nThe osmdata package for extracting coastline data (Massicotte and South 2023)\nThe modelsummary package for outputting regression results (Arel-Bundock 2022)\nThe ggnewscale package for help with layered plots (Campitelli 2024)\nThe nnet for simple neural networks (Venables and Ripley 2002a)\n\n\n# load packages\nlibrary(tidyverse)\nlibrary(terra)\nlibrary(RColorBrewer)\nlibrary(sf)\nlibrary(leaflet)\nlibrary(osmdata)\nlibrary(modelsummary)\nlibrary(ggnewscale)\nlibrary(nnet)"
  },
  {
    "objectID": "lsmodelling.html#introduction",
    "href": "lsmodelling.html#introduction",
    "title": "LandSat 8 Modelling",
    "section": "",
    "text": "The first methodological step is to train a variety of models predicting LST using LandSat 8 at 30m resolution. This is in a similar process to Onačillová et al. (2022); Equere et al. (2021); Son et al. (2017); Karyati et al. (2022). In this modelling process we employ three types of modelling approaches:\n\nLinear Regression (Onačillová et al. 2022)\nAdvanced Neural Networks (Equere et al. 2021)\nGeographically Weighted Regression\n\nThrough comparing the accuracy of these models we make inferences on which is most likely to provide high utility data for use in modelling 10m resolution LST with Sentinel 2 ºdata as input."
  },
  {
    "objectID": "lsmodelling.html#input-data",
    "href": "lsmodelling.html#input-data",
    "title": "LandSat 8 Modelling",
    "section": "Input Data",
    "text": "Input Data\nTo train these models, we use input data from Landsat covering and clipped to our study area of Maspalomas-Playa del Inglés. This raster data is broken down into broken down into bands from which the following can be calculated:\n\nLST\nNDVI\nNDBI\nNDSI (normalised difference sand index)\nSurface Albedo\n\nWe will also use the following auxiliary data\n\nRoad Proximity (from OSM)\nRasterised Water Features (from OSM)\nProximity to Coast/Ocean\nElevation"
  },
  {
    "objectID": "lsmodelling.html#libraries",
    "href": "lsmodelling.html#libraries",
    "title": "LandSat 8 Modelling",
    "section": "",
    "text": "This methodology will use the following r packages for data wrangling using data from July 24th 2023 (a day when both Sentinel and Landsat imagery coincides).\n\nThe tidyverse family of packages (Wickham et al. 2019), which includes\n\ndplyr for wrangling data (Wickham et al. 2023)\ntidyr for managing data sets (Wickham, Vaughan, and Girlich 2024)\nggplot2 for visualisations (Wickham 2016)\n\nThe terra package for handling raster data (Hijmans 2024)\nThe RColorBrewer package for colour scales (Neuwirth 2022)\nThe sf package for handling shapefile data (Pebesma and Bivand 2023)\nThe leaflet package for interactive visualisation (Cheng et al. 2023)\nThe osmdata package for extracting coastline data (Massicotte and South 2023)\nThe modelsummary package for outputting regression results (Arel-Bundock 2022)\nThe ggnewscale package for help with layered plots (Campitelli 2024)\nThe nnet for simple neural networks (Venables and Ripley 2002a)\n\n\n# load packages\nlibrary(tidyverse)\nlibrary(terra)\nlibrary(RColorBrewer)\nlibrary(sf)\nlibrary(leaflet)\nlibrary(osmdata)\nlibrary(modelsummary)\nlibrary(ggnewscale)\nlibrary(nnet)"
  },
  {
    "objectID": "lsmodelling.html#loading-rasters",
    "href": "lsmodelling.html#loading-rasters",
    "title": "LandSat 8 Modelling",
    "section": "Loading Rasters",
    "text": "Loading Rasters\nThese rasts denote different bands of EM radiation captured by the LandSat 8 satellite over the south of Gran Canaria at 11:29am on the 24th July 2023 (U. S. Geological Surey 2023). These bands cover most of the visible light spectrum as well as the infrared spectrum. Combined in various was they can be used to calculate various measures such as the NDVI (normalised difference vegetation index) and the LST (land surface temperature).\nFirst lets plot and load the rasts\n\n# function to plot raster with a label and custome colour scale\nplot_rast = function(raster, label, colors) {\n  terra::plot(raster, col=colorRampPalette(colors)(100))\n  mtext(text=label, side=3, line=2)\n}\n\n# define the bounding box epsg:4083\nbbox = ext(c(437292.6282,445376.8775,3067829.6809,3072637.1023))\n\n# load each raster, crop to bounding box, and plot with label\nb1 = crop(rast(\"landsat/B1.TIF\"), bbox)\nb2 = crop(rast(\"landsat/B2.TIF\"), bbox)\nb3 = crop(rast(\"landsat/B3.TIF\"), bbox)\nb4 = crop(rast(\"landsat/B4.TIF\"), bbox)\nb5 = crop(rast(\"landsat/B5.TIF\"), bbox)\nb6 = crop(rast(\"landsat/B6.TIF\"), bbox)\nb7 = crop(rast(\"landsat/B7.TIF\"), bbox)\nb10 = crop(rast(\"landsat/B10.TIF\"), bbox)\n\n# load elevation raster, resample, and crop\nstrm = rast(\"strm/strm.tif\") %&gt;% \n  project(crs(b1)) %&gt;%\n  resample(b1, method = \"bilinear\") %&gt;%\n  crop(bbox)"
  },
  {
    "objectID": "lsmodelling.html#calculating-ndvi",
    "href": "lsmodelling.html#calculating-ndvi",
    "title": "LandSat 8 Modelling",
    "section": "Calculating NDVI",
    "text": "Calculating NDVI\nPerhaps the most important metric beside LST is NVDI. NDVI is also used in the computation of impassivity and ultimately therefore emissivity adjusted LST.\nTo calculate NDVI, the following formula is used:\n\\[\n\\text{NDVI} = \\frac{\\text{NIR} - \\text{Red}}{\\text{NIR} + \\text{Red}}\n\\]\nHere \\(NIR\\) represents the Near-Infrared band reflectance value, in Landsat 8 this is Band 5. Further \\(Red\\) represents the Red band reflectance value, in Landsat 8 this is Band 4.\n\n# calc and plot ndvi using bands 5 and 4\nndvi = (b5-b4)/(b5+b4)\n\nplot_rast(ndvi,\n          \"Normalised Difference Vegetation Index (NDVI)\",\n          c(\"brown\", \"green\"))"
  },
  {
    "objectID": "lsmodelling.html#calculating-lst",
    "href": "lsmodelling.html#calculating-lst",
    "title": "LandSat 8 Modelling",
    "section": "Calculating LST",
    "text": "Calculating LST\nCalculating LST can be straightforward in principle, using Band 10 alone of Landsat 8 data. However, this will not account for surface emissivity. Thus, for this study, an adjusted LST is calculated.\n\nTop of Atmosphere Spectral Radiance\nThe first step is to convert the Digital Numbers \\(DN\\) in the Band 10 layer to Top of Atmosphere Spectral Radiance \\(L_\\lambda\\) values. This process uses input units found the images metadata/MLT file. These values are the RADIANCE_MULT_BAND_10 \\(M_L\\) and the RADIANCE_ADD_BAND_10 \\(\\text{A}_L\\).\nPutting these together into a formula is as follows:\n\\[\n\\text{L}_\\lambda = \\text{M}_L · \\text{DN} + \\text{A}_L\n\\]\n\n# define metadata values\nmult_b10 = 3.8e-04\nadd_b10 = 0.1\n\n# calc and plot\nl = (mult_b10*b10+add_b10)\n\nplot_rast(l,\n          expression(Spectral~Radiance~(L[lambda])),\n          c(\"brown\", \"yellow\"))\n\n\n\n\n\n\nAt-Sensor Temperature\nThe second step is “Conversion of Radiance to At-Sensor Temperature” (Karyati et al. 2022). This This converts the Spectral Radiance into temperature values or Brightness Temperature \\(BT\\) in Kelvin. This process requires two constants related to Landsat 8 Band 10’s specific thermal conversion constants found again in the metadata file. These are \\(K1\\)and \\(K2\\).\nPutting this together into a formula is as follows:\n\\[\n\\text{BT} = \\frac{\\text{K2}}{ln(\\frac{\\text{K1}}{\\text{L}_\\lambda} + 1)}\n\\]\n\n# add effective wavelength of landsat b10\nk1 = 799.0284\nk2 = 1329.2405\n\n# calc and plot\nbt = (k2/log(k1/l+1))\n\nplot_rast(bt,\n          expression(Brightness~Temp~(BT)),\n          c(\"blue\", \"red\")) \n\n\n\n\n\n\nSurface Level Emissivity\nThe above metric alone could be used for study of heat distribution, however it does not account for the variation caused by surface level emissivity. Emissivity denotes how much infrared a surface will absorb or reflect, ranging from a mirror to a perfect black surface. The values of emissivity range from 0 to 1 respectively.\n\nFractional Vegetation Factor\nNDVI is used to determine emissivity, through the fractional vegetation factor \\(\\text{P}_v\\). This value is specific to the region being studied.\nThe formula for calculating fractional vegetation factor is as follows:\n\\[\n\\text{P}_v = \\left( \\frac{\\text{NDVI} - \\text{NDVI}_{\\min}}{\\text{NDVI}_{\\max} - \\text{NDVI}_{\\min}} \\right)^2\n\\]\n\n# define min and max ndvi\nmin_ndvi = global(ndvi, fun=min, na.rm=TRUE) %&gt;%\n  as.numeric()\nmax_ndvi = global(ndvi, fun=max, na.rm=TRUE) %&gt;%\n  as.numeric()\n\n# calc and plot vegetation factor\npv = ((ndvi-min_ndvi)/(max_ndvi-min_ndvi))^2\n\nplot_rast(pv,\n          expression(Fractional~Vegetation~Factor~(P[v])),\n          c(\"maroon\", \"green\"))\n\n\n\n\n\n\nEmissivity\nFrom this the surface emissivity can be calculated. This uses two constants relating to the relative emissivity of soil \\(\\epsilon\\text{s}\\lambda\\) and the emissivity of vegetation \\(\\epsilon\\text{v}\\lambda\\), as well as one surface roughness \\(\\text{C}\\lambda\\) metric of 0.005\nThe formula for estimating emissivity \\(\\epsilon\\lambda\\) is thus as follows:\n\\[\n\\epsilon\\lambda = \\epsilon\\text{v}\\lambda + \\epsilon\\text{s}\\lambda  · (1 - \\text{P}_v) + \\text{C}\\lambda\n\\]\n\n# soil emissivity\nes = 0.964\n\n# veg emissivity\nev = 0.984\n\n# calc and plot emissivity\ne =  ev*pv+es*(1-pv)+0.005\n\nplot_rast(e,\n          expression(Emissivity~(epsilon*lambda)),\n          c(\"yellow\", \"darkgreen\"))\n\n\n\n\n\n\n\nCorrection Constant\nNow most of the building blocks are in place to calculate the adjusted LST. This requires a correction constant \\(\\rho\\) that incorporates the Speed of Light \\(c\\), Planck’s constant \\(h\\), and Boltzmann’s constant \\(\\sigma\\).\nThe formula for this is as follows:\n\\[\n\\rho = \\frac{c·h}{\\sigma}\n\\]\n\n# speed of light\nc = 2.997925e8 \n\n# planck's constant\nh = 6.626070e-34\n\n# boltzmann's constant\nsigma = 1.380649e-23\n\n# calc and output correction constant/rho \nrho = c*h/sigma\nrho\n\n[1] 0.01438777\n\n\n\n\nLand Surface Temperature\nWith these building blocks, plus the wavelength of the emitted radiance for Landsat 8 \\(\\lambda\\), the adjusted LST \\(\\text{T}s\\) can be determined using the following formula (converting from Kelvin to Celcius:\n\\[\n\\text{T}_s = \\frac{\\text{BT}}{1 + (\\frac{\\lambda\\text{BT}}{\\rho} · ln(\\epsilon\\lambda))} - 273.15\n\\]\n\n# wavelength\nwl = 10.895e-6\n\n# calc and plot\nts = bt/(1+(wl*bt/rho)*log(e))-273.15\n\nplot_rast(ts,\n          expression(Land~Surface~Temperature~(T[s])), c(\"blue\", \"red\"))\n\n\n\n\n\nLeaflet Visualisation of LST\nUsing the Leaflet Package for R (Cheng et al. 2023), we can visualise the resulting rast\n\nplet(ts,\n     col=(c(\"darkblue\",\"pink\")),\n     legend=\"bottomright\",\n     main=\"LST (Cº)\",\n     tiles=c(\"Esri.WorldImagery\"))"
  },
  {
    "objectID": "lsmodelling.html#leaflet-visualisation-of-lst",
    "href": "lsmodelling.html#leaflet-visualisation-of-lst",
    "title": "LandSat 8 Modelling",
    "section": "Leaflet Visualisation of LST",
    "text": "Leaflet Visualisation of LST\nUsing the Leaflet Package for R (Cheng et al. 2023), we can visualise the resulting raster\n\npal = colorNumeric(c(\"#0C2C84\", \"#41B6C4\", \"red\"),\n                   values(ts),\n                   na.color = \"transparent\")\n\nleaflet() %&gt;% addTiles() %&gt;%\n  addRasterImage(ts, colors = pal, opacity = 0.9) %&gt;%\n  addLegend(pal = pal, values = values(ts),\n    title = \"LST (Cº)\")\n\n\n\n\n\nBack to Main Menu"
  },
  {
    "objectID": "lsmodelling.html#loading-coast-shapefile",
    "href": "lsmodelling.html#loading-coast-shapefile",
    "title": "LandSat 8 Modelling",
    "section": "Loading Coast Shapefile",
    "text": "Loading Coast Shapefile\nUsing OSM Data to first extract a coastline of the island, this process enables such analysis as calculating distance from the coastline\n\n# query osm\ngran_canaria_query = opq(bbox = \"Gran Canaria\") %&gt;%\n  add_osm_feature(key = \"place\", value = \"island\") %&gt;%\n  osmdata_sf()\n# extract the coast data\ngran_canaria_sf = gran_canaria_query$osm_multipolygons\n\n# make spatial vector\ngran_canaria_vect = st_transform(gran_canaria_sf, crs(b1)) %&gt;%\n  vect()"
  },
  {
    "objectID": "lsmodelling.html#loading-road-shapefile",
    "href": "lsmodelling.html#loading-road-shapefile",
    "title": "LandSat 8 Modelling",
    "section": "Loading Road Shapefile",
    "text": "Loading Road Shapefile\nAgain using OSM data, it is possible to extract road data in the form of a spatial vector.\n\n# define bbox\nbbox_osm = c(-15.636205673397361,\n             27.73337624747081,\n             -15.554409027542757,\n             27.777126576546703)\n\n# query osm\nosm_roads = opq(bbox = bbox_osm) %&gt;%\n  add_osm_feature(key = \"highway\") %&gt;%\n  osmdata_sf()\n\n# extract road lines\nroads_vect = st_transform(osm_roads$osm_lines, crs(b1)) %&gt;%\n  vect()"
  },
  {
    "objectID": "lsmodelling.html#masking-ocean-values",
    "href": "lsmodelling.html#masking-ocean-values",
    "title": "LandSat 8 Modelling",
    "section": "Masking Ocean Values",
    "text": "Masking Ocean Values\n\nb1 = mask(b1, gran_canaria_vect)\nb2 = mask(b2, gran_canaria_vect)\nb3 = mask(b3, gran_canaria_vect)\nb4 = mask(b4, gran_canaria_vect)\nb5 = mask(b5, gran_canaria_vect)\nb6 = mask(b6, gran_canaria_vect)\nb7 = mask(b7, gran_canaria_vect)\nb10 = mask(b10, gran_canaria_vect)\nstrm = mask(strm, gran_canaria_vect)"
  },
  {
    "objectID": "lsmodelling.html#calculating-ndbi",
    "href": "lsmodelling.html#calculating-ndbi",
    "title": "LandSat 8 Modelling",
    "section": "Calculating NDBI",
    "text": "Calculating NDBI\nAnother important metric is NDBI as urban artificial surfaces may trap heat causing excess heating relative to vegetated surfaces.\nTo calculate NDBI for Landsat 8, the following formula is used (Abulibdeh 2021):\n\\[\n\\text{NDVI} = \\frac{\\text{MIR} - \\text{NIR}}{\\text{MIR} + \\text{NIR}}\n\\]\nHere \\(NIR\\) again represents the Middle-Infrared band value, in Landsat 8 this is Band 5. Also \\(NIR\\) again represents the Near-Infrared band value, being Landsat 8 Band 5.\nHowever, we may not use this as for arid areas it has reduced efficacy. Instead we may rasterise OSM building data.\n\nndbi = (b6-b5)/(b6+b5)\n\nplot_rast(ndbi,\n          \"Normalised Difference Built Index (NDBI)\",\n          c(\"lightgreen\", \"black\"))"
  },
  {
    "objectID": "lsmodelling.html#calculating-ndwi",
    "href": "lsmodelling.html#calculating-ndwi",
    "title": "LandSat 8 Modelling",
    "section": "Calculating NDWI",
    "text": "Calculating NDWI\nComplementing these metrics is NDWI, here used to analyse the impact that surface water has upon the temperature.\nTo calculate NWBI for Landsat 8, the following formula is used:\n\\[\n\\text{NDVI} = \\frac{\\text{Green} - \\text{SWIR}}{\\text{Green} + \\text{SWIR}}\n\\]\nHere \\(Green\\) represents the Green reflectance values, in Landsat 8 this is Band 3. Also \\(SWIR\\) again represents the Short-Infrared band value, being Landsat 8 Band 7.\n\n# calc and plot\nndwi = (b3-b7)/(b3+b7)\n\nplot_rast(ndwi,\n          \"Normalised Difference Water Index (NDWI)\",\n          c(\"yellow\", \"blue\"))"
  },
  {
    "objectID": "lsmodelling.html#calculating-surface-albedo",
    "href": "lsmodelling.html#calculating-surface-albedo",
    "title": "LandSat 8 Modelling",
    "section": "Calculating Surface Albedo",
    "text": "Calculating Surface Albedo\nThere is also surface albedo \\(\\alpha\\), which is the the fraction of the reflected shortwave radiation, is calculated using the following formula (Equere et al. 2021):\n\\[\n\\alpha = \\frac{0.356·\\text{Blue} + 0.0130 · \\text{Red} + 0.373 · \\text{NIR} + 0.085 * \\text{MIR} + 0.072 · \\text{SWIR} - 0.0018}{1.016}\n\\]\nHere \\(Blue\\) represents the Blue reflectance values, in Landsat 8 this is Band 2. \\(Red\\) again represents the Red band value, being Landsat 8 Band 4. \\(NIR\\) represents the Near-Infrared values, in Landsat 8 this is Band 5. \\(MIR\\) likewise represents the Middle-Infrared values, being Landsat 8 Band 6. Finally \\(SWIR\\) represents the Near-Infrared values, in Landsat 8 this is Band 7.\n\n# calc and plot\nalbedo = (0.356*b2+0.0130*b4+0.373*b5+0.085*b6+0.072*b7-0.0018)/1.016\n\nplot_rast(albedo,\n          expression(paste(\"Surface Albedo (\", alpha,\")\")),\n          c(\"pink\", \"blue\"))"
  },
  {
    "objectID": "lsmodelling.html#calculating-distance-from-ocean",
    "href": "lsmodelling.html#calculating-distance-from-ocean",
    "title": "LandSat 8 Modelling",
    "section": "Calculating Distance from Ocean",
    "text": "Calculating Distance from Ocean\nIn terms of other environmental variables, there is also distance from the coast to consider, calculated using OSM coastline data.\n\n# create blank template\ntemplate = crop(rast(\"landsat/B1.TIF\"), bbox)\n\n# crop sp by bbox\ngran_canaria_vect = crop(gran_canaria_vect, bbox)\n\n# create land raster\nsea_mask = rasterize(gran_canaria_vect,\n                      template,\n                      NA,\n                      background=1)\n\n\n# calc distance and plot\ncoastdistance = distance(sea_mask) %&gt;%\n  mask(gran_canaria_vect) / 1000\nterra::plot(coastdistance, col = hcl.colors(100))\nplot(gran_canaria_vect, add = TRUE)\nmtext(text=\"Coastal Distance (km)\", side=3, line=2)"
  },
  {
    "objectID": "lsmodelling.html#calculating-distance-from-roads",
    "href": "lsmodelling.html#calculating-distance-from-roads",
    "title": "LandSat 8 Modelling",
    "section": "Calculating Distance from Roads",
    "text": "Calculating Distance from Roads\nFurthermore, there is distance from the nearest road, again calculated using OSM data.\n\n# create road raster\nroad_mask = rasterize(roads_vect,\n                      template,\n                      1,\n                      background=NA)\n\n# calc distance and plot\nroaddistance = distance(road_mask) %&gt;%\n  mask(gran_canaria_vect) / 1000\nplot(roaddistance, col = hcl.colors(100))\nplot(gran_canaria_vect, add = TRUE)\nmtext(text=\"Road Distance (km)\", side=3, line=2)"
  },
  {
    "objectID": "lsmodelling.html#calculating-elevation",
    "href": "lsmodelling.html#calculating-elevation",
    "title": "LandSat 8 Modelling",
    "section": "Calculating Elevation",
    "text": "Calculating Elevation\nAs elevation is already loaded in 30m resolution the STRM project. The processing steps here are just to plot and visualise it.\n\n# plot\nplot_rast(strm,\n          \"Elevation (m)\",\n          c(\"green\", \"brown\"))"
  },
  {
    "objectID": "lsmodelling.html#general-linear-model",
    "href": "lsmodelling.html#general-linear-model",
    "title": "LandSat 8 Modelling",
    "section": "General Linear Model",
    "text": "General Linear Model\nThe first model is simply multivariate linear regression fitted within a OLS framework. The formula for this model is:\n\\[\n\\text{T}_{si} = a_0+a _1\\text{NDVI}_i+a _2\\text{NDBI}_i+a _3\\text{NDWI}_i+a _4\\text{Albedo}_i+a _5\\text{Coast}_i+ a _6\\text{Road}_i + \\text{Elevation}_i + \\epsilon_i\n\\]\nWhere \\(i\\) denotes the individual 30m raster tiles and \\(\\epsilon\\) denotes the residual error not accounted for.\n\nrast_stack = c(ts, ndvi, ndbi, ndwi, coastdistance, roaddistance, strm)\n\ndata_df = na.omit(as.data.frame(rast_stack, xy=TRUE))\n\nnames(data_df) = c(\"X\", \"Y\", \"LST\", \"NDVI\", \"NDBI\", \"NDWI\", \"CoastDistance\", \"RoadDistance\", \"Elevation\")\n\nols = lm(LST ~ \n           NDVI +\n           NDBI +\n           NDWI +\n           CoastDistance +\n           RoadDistance +\n           Elevation,\n         data=data_df)\n\nmodelsummary(ols, type = \"html\")\n\n\n\n\n\n (1)\n\n\n\n\n(Intercept)\n36.563\n\n\n\n(0.025)\n\n\nNDVI\n−8.432\n\n\n\n(0.286)\n\n\nNDBI\n0.888\n\n\n\n(0.482)\n\n\nNDWI\n−11.320\n\n\n\n(0.318)\n\n\nCoastDistance\n0.560\n\n\n\n(0.013)\n\n\nRoadDistance\n0.008\n\n\n\n(0.000)\n\n\nElevation\n−0.003\n\n\n\n(0.000)\n\n\nNum.Obs.\n33086\n\n\nR2\n0.451\n\n\nR2 Adj.\n0.451\n\n\nAIC\n123668.3\n\n\nBIC\n123735.5\n\n\nLog.Lik.\n−61826.135\n\n\nRMSE\n1.57"
  },
  {
    "objectID": "lsmodelling.html#single-layer-neural-network",
    "href": "lsmodelling.html#single-layer-neural-network",
    "title": "LandSat 8 Modelling",
    "section": "Single Layer Neural Network",
    "text": "Single Layer Neural Network\nThe second model is a straightforward single layer neural network using the nnet package (Venables and Ripley 2002b). This is slightly different from the work of Equere et al. (2021), who use two hidden layers. The steps for building this model are as follows:\n\nNormalise the Data\nIt is best practice to scale all the values in our dataset \\(X\\) to be ranged from -1 to 1. This is achieved with the standard normalisation algorithm.\n\\[\nX_{\\text{scaled}} = \\frac{x - X_{\\text{min}}}{X_{\\text{max}} - X_{\\text{min}}}\n\\]\n\n# normalize your data\nmaxs = apply(data_df, 2, max) \nmins = apply(data_df, 2, min)\nscaled_data_df = as.data.frame(scale(data_df,\n                                     center = mins,\n                                     scale = maxs - mins))\n\n\n\nData Splitting\nNext it is important to split the data in to train \\(X_{\\text{train}}\\) and test \\(X_{\\text{test}}\\) sets. One for building the model and one for testing its fit. This split is on an 80:20 ratio respectively.\n\n# split the data \nset.seed(1999) # my year of birth\nindexes = sample(1:nrow(scaled_data_df),\n                 size = 0.8 * nrow(scaled_data_df))\n# use index to split\ntrain_data = scaled_data_df[indexes, ]\ntest_data = scaled_data_df[-indexes, ]\n\n\n\nFitting the Model\nTo fit the model we first define it as a method to determine LST \\(T_s\\) as a function of the input data \\(X\\) utilsing a set of weights \\(W\\) and biases \\(b\\).\n\\[\nT_s = f(X; W, b)\n\\]\n\n# define the model\nformula = LST ~\n  NDVI +\n  BuildingExposure +\n  NDWI +\n  CoastDistance +\n#  RoadExposure +\n  TourismExposure +\n  Elevation\n\nThe model is defined as having one hidden layer and thus two activation steps. The first step is defining inital weights \\(W^{[1]}\\) and biases \\(b^{[1]}\\) to take the input layer to the hidden layer \\(Z^{[1]}\\).\n\\[\nZ^{[1]} = W^{[1]}X + b^{[1]}\n\\]\nThis is is then put into an initial activation function \\(g^{[1]}\\) in the hidden layer to get the first activation \\(A^{[1]}\\) \\[\nA^{[1]} = g^{[1]}(Z^{[1]})\n\\]\nNext this hidden layer activation has applied to it another set of defined weights \\(W^{[2]}\\) and biases \\(b^{[2]}\\) to reach our predicted output \\(\\hat{T_s}\\)\n\\[\n\\hat{T_s} = W^{[2]}A^{[1]} + b^{[2]}\n\\]\n\n# model has 4 neurons on hidden layer, decay of 0.00004 to prevent overfitting, and 200 iterations\nmodel = nnet(formula,\n             data=train_data,\n             size=4,\n             linout=TRUE, \n             decay=5e-4, \n             maxit=250)\n\n# weights:  33\ninitial  value 21890.515539 \niter  10 value 370.778704\niter  20 value 231.925917\niter  30 value 197.858729\niter  40 value 190.911812\niter  50 value 187.378635\niter  60 value 183.193713\niter  70 value 180.169833\niter  80 value 179.243140\niter  90 value 176.897444\niter 100 value 174.966091\niter 110 value 172.584543\niter 120 value 169.012801\niter 130 value 167.101546\niter 140 value 163.455271\niter 150 value 145.754606\niter 160 value 138.552257\niter 170 value 136.318115\niter 180 value 135.539872\niter 190 value 135.121526\niter 200 value 135.001745\niter 210 value 134.961821\niter 220 value 134.887461\niter 230 value 134.702007\niter 240 value 134.459003\niter 250 value 134.209220\nfinal  value 134.209220 \nstopped after 250 iterations\n\n\n\n\nTesting Fit and Predictive Ability\nUsing the \\(X_\\text{test}\\) dataset we can also see the fit of the model and test its predictive ability.\n\n# make predictions and test with actuals\npredictions = predict(model,\n                      newdata=test_data[, -which(names(test_data) == \"LST\")])\n\nactuals = test_data$LST # actual values\nmse = mean((predictions - actuals)^2)\nrmse = sqrt(mse)\n\ncat(\"MSE:\", mse, \"\\n\")\n\nMSE: 0.005102267 \n\ncat(\"RMSE:\", rmse, \"\\n\")\n\nRMSE: 0.07143015 \n\n# calc r squared\nSST = sum((actuals - mean(actuals))^2)\nSSR = sum((predictions - actuals)^2)\nr_squared = 1 - (SSR/SST)\ncat(\"R^2:\", r_squared, \"\\n\")\n\nR^2: 0.6993533 \n\n\n\n\nPlot Fit\nWe can also plot the fit of the model as a bivariate line graph between predictions and actuals, reversing the normalising first.\n\n# reverse norm\nmax_LST = max(data_df$LST)\nmin_LST = min(data_df$LST)\n\npredictions_original = predictions * (max_LST - min_LST) + min_LST\nactuals_original = actuals * (max_LST - min_LST) + min_LST\n\n# plot\nplot(actuals_original, predictions_original, xlab = \"Actual\", ylab = \"Predicted\",\n     main = \"Predicted vs. Actual Values\")\nabline(0, 1)"
  },
  {
    "objectID": "lsmodelling.html#loading-tourism-shapefile",
    "href": "lsmodelling.html#loading-tourism-shapefile",
    "title": "LandSat 8 Modelling",
    "section": "Loading Tourism Shapefile",
    "text": "Loading Tourism Shapefile\n\n# query osm\nosm_tourism = opq(bbox = bbox_osm) %&gt;%\n  add_osm_feature(key = \"tourism\") %&gt;%\n  osmdata_sf()\n\n# extract tourism points\ntourism_vect = st_transform(osm_tourism$osm_points, crs(b1)) %&gt;%\n  vect()\n\nplot(tourism_vect)"
  },
  {
    "objectID": "lsmodelling.html#calculating-distance-from-tourism-points",
    "href": "lsmodelling.html#calculating-distance-from-tourism-points",
    "title": "LandSat 8 Modelling",
    "section": "Calculating Distance from Tourism Points",
    "text": "Calculating Distance from Tourism Points\nFurthermore, there is distance from the nearest tourism structure, again calculated using OSM data.\n\n# create road raster\ntourism_mask = rasterize(tourism_vect,\n                         template,\n                         1,\n                         background=NA)\n# calc distance and plot\ntourismdistance = distance(tourism_mask) %&gt;%\n  mask(gran_canaria_vect) / 1000\nplot(tourismdistance, col = hcl.colors(100))\nplot(gran_canaria_vect, add = TRUE)\nmtext(text=\"Tourism Distance (km)\", side=3, line=2)"
  },
  {
    "objectID": "lsmodelling.html#general-linear-models",
    "href": "lsmodelling.html#general-linear-models",
    "title": "LandSat 8 Modelling",
    "section": "General Linear Models",
    "text": "General Linear Models\nThe first GLM model is simply multivariate linear regression fitted within a OLS framework.\n\nFitting the Model\nThe formula for this model is:\n\\[\n\\text{T}_{si} = a_0+a _1\\text{Tourism}_i+a _2\\text{Buildings}_i+a _3\\text{NDVI}_i+a _4\\text{NDWI}_i+a _5\\text{Coast}_i + a _6\\text{Elevation}_i + \\epsilon_i\n\\]\nWhere \\(i\\) denotes the individual 30m raster tiles and \\(\\epsilon\\) denotes the residual error not accounted for.\nAlso, there is analysis of a potential interaction effect between tourism distance and NDBI, as the types of built up area may vary as we move from a tourism heavy area, thus also adding the following term to the OLS function.\n\\[\na_7\\text{Tourism · NDVI}\n\\]\nWe will run these models at all levels of building concentration and only at the high concentrations of buildings (&gt;2)\n\nrast_stack = c(ts, ndvi, ndwi, coastdistance, scale(albedo),\n               tourism_heat, building_heat, strm)\n\ndata_df = na.omit(as.data.frame(rast_stack, xy=TRUE))\n\nnames(data_df) = c(\"X\", \"Y\", \n                   \"LST\", \"NDVI\", \"NDWI\", \"CoastDistance\",\n                   \"Albedo\", \"TourismExposure\",\n                   \"BuildingExposure\", \"Elevation\")\n\n# define high density\nhd_data_df = data_df %&gt;% filter(BuildingExposure &gt; 0.5)\n\n# compute models\nols_models = list(\n  \"OLS 1\" = lm(LST ~ \n               TourismExposure +\n               BuildingExposure +\n               Albedo +\n               NDVI +\n               NDWI +\n               CoastDistance +\n               Elevation,\n             data=data_df),\n  \"OLS 2 (Interaction)\" = lm(LST ~                                                                                TourismExposure*BuildingExposure +\n                             Albedo +\n                             NDVI +\n                             NDWI +\n                             CoastDistance +\n                             Elevation,\n                           data=data_df),\n  \"OLS 3 (High Density)\" = lm(LST ~ \n                              TourismExposure +\n                              BuildingExposure +\n                              Albedo +  \n                              NDVI +\n                              NDWI +\n                              CoastDistance +\n                              Elevation,\n                             data=hd_data_df),\n  \"OLS 4 (High Density, Interaction)\" = lm(LST ~                                                                                TourismExposure*BuildingExposure +\n                                           Albedo +    \n                                           NDVI +\n                                           NDWI +\n                                           CoastDistance +\n                                           Elevation,\n                                          data=hd_data_df))\n\nmodelsummary(ols_models, stars = TRUE)\n\n\n\n\n\nOLS 1\n OLS 2 (Interaction)\n OLS 3 (High Density)\n OLS 4 (High Density, Interaction)\n\n\n\n\n(Intercept)\n37.402***\n37.373***\n36.521***\n36.427***\n\n\n\n(0.024)\n(0.025)\n(0.053)\n(0.054)\n\n\nTourismExposure\n−0.298***\n−0.353***\n−0.143***\n0.012\n\n\n\n(0.012)\n(0.018)\n(0.012)\n(0.024)\n\n\nBuildingExposure\n−0.330***\n−0.320***\n−0.010\n0.064**\n\n\n\n(0.012)\n(0.012)\n(0.020)\n(0.023)\n\n\nAlbedo\n0.178***\n0.175***\n−0.248***\n−0.243***\n\n\n\n(0.009)\n(0.009)\n(0.010)\n(0.010)\n\n\nNDVI\n−10.345***\n−10.334***\n−8.863***\n−8.841***\n\n\n\n(0.109)\n(0.109)\n(0.178)\n(0.178)\n\n\nNDWI\n−9.884***\n−9.856***\n−2.594***\n−2.631***\n\n\n\n(0.165)\n(0.165)\n(0.177)\n(0.177)\n\n\nCoastDistance\n0.566***\n0.579***\n0.599***\n0.560***\n\n\n\n(0.013)\n(0.013)\n(0.018)\n(0.019)\n\n\nElevation\n−0.007***\n−0.007***\n0.003***\n0.004***\n\n\n\n(0.000)\n(0.000)\n(0.001)\n(0.001)\n\n\nTourismExposure × BuildingExposure\n\n0.054***\n\n−0.115***\n\n\n\n\n(0.013)\n\n(0.016)\n\n\nNum.Obs.\n33086\n33086\n9423\n9423\n\n\nR2\n0.457\n0.457\n0.490\n0.493\n\n\nR2 Adj.\n0.456\n0.457\n0.489\n0.492\n\n\nAIC\n123331.0\n123316.1\n27200.7\n27149.3\n\n\nBIC\n123406.7\n123400.2\n27265.1\n27220.8\n\n\nLog.Lik.\n−61656.497\n−61648.059\n−13591.349\n−13564.631\n\n\nRMSE\n1.56\n1.56\n1.02\n1.02\n\n\n\n + p &lt; 0.1, * p &lt; 0.05, ** p &lt; 0.01, *** p &lt; 0.001\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot Fit\n\n# all building concentrations \ntourism_area = tibble(\n  TourismExposure = 2,\n  NDVI = mean(data_df$NDVI),\n  BuildingExposure = seq(min(data_df$BuildingExposure),\n                         max(data_df$BuildingExposure),\n                         by = 0.05),\n  Albedo = mean(data_df$Albedo),\n  NDWI = mean(data_df$NDWI),\n  CoastDistance = mean(data_df$CoastDistance),\n  Elevation = mean(data_df$Elevation)\n)\n\nresidence_area = tibble(\n  TourismExposure = -0.6,\n  NDVI = mean(data_df$NDVI),\n  BuildingExposure = seq(min(data_df$BuildingExposure),\n                         max(data_df$BuildingExposure),\n                         by = 0.05),\n  Albedo = mean(data_df$Albedo),\n  NDWI = mean(data_df$NDWI),\n  CoastDistance = mean(data_df$CoastDistance),\n  Elevation = mean(data_df$Elevation)\n)\n\n# bind together\nscenario = rbind(tourism_area, residence_area)\n\n# predict values\narea_predictions = predict(\n  ols_models$`OLS 2`,\n  newdata = scenario,\n  se.fit = TRUE,\n  interval = \"confidence\"\n)\n\n# make tibble\narea_predictions = area_predictions$fit %&gt;% \n  as_tibble()\n\n# make toplot\ntoplot = bind_cols(scenario,\n                   area_predictions)\n\ntoplot = select(toplot, c(\"fit\", \"lwr\", \"upr\",\n                          \"BuildingExposure\",\n                          \"TourismExposure\"))\n\ntoplot$area = ifelse(toplot$TourismExposure == -0.6, \"Residence\",\n                     \"Tourist\")\n\n# plot all density\n\nall_density_plot = ggplot() +\n  geom_line(data = toplot,\n            aes(x = BuildingExposure,\n                y = fit,\n                colour = area),\n            alpha = 2) +\n  scale_colour_manual(values = c(\"Residence\" = \"blue\", \"Tourist\" = \"red\"),\n                      name = \"Area Type\") +\n  new_scale_color() +\n  geom_point(data = data_df,\n             aes(x = BuildingExposure,\n                 y = LST,\n                 colour = TourismExposure),\n             alpha = 0.02) +\n  scale_color_viridis_c(name = \"Tourism Concentration\") +\n  labs(title = \"Effects of Building Concentration on Land Surface Temperature\",\n       subtitle = \"All Building Concentrations,\nMaspalomas/Playa del Inglés region of Gran Canaria\",\n       caption = \"Model Based on LandSat Imagery from 27th July 2023\",\n       x = \"Building Concentration Index\",\n       y = \"Predicted Land Surface Temperature ºC\")\n\nall_density_plot\n\n\n\n\n\n# hd building concentrations \nhd_tourism_area = tibble(\n  TourismExposure = 4,\n  NDVI = mean(hd_data_df$NDVI),\n  BuildingExposure = seq(0.5, \n                        max(hd_data_df$BuildingExposure),\n                        by = 0.05),\n  Albedo = mean(data_df$Albedo),\n  NDWI = mean(hd_data_df$NDWI),\n  CoastDistance = mean(hd_data_df$CoastDistance),\n  Elevation = mean(hd_data_df$Elevation)\n)\n\nhd_residence_area = tibble(\n  TourismExposure = -0.6,\n  NDVI = mean(hd_data_df$NDVI),\n  BuildingExposure = seq(0.5, \n                        max(hd_data_df$BuildingExposure),\n                        by = 0.05),\n  Albedo = mean(data_df$Albedo),\n  NDWI = mean(hd_data_df$NDWI),\n  CoastDistance = mean(hd_data_df$CoastDistance),\n  Elevation = mean(hd_data_df$Elevation)\n)\n\n# bind together\nhd_scenario = rbind(hd_tourism_area, hd_residence_area)\n\n# predict values\nhd_area_predictions = predict(\n  ols_models$`OLS 4`,\n  newdata = hd_scenario,\n  se.fit = TRUE,\n  interval = \"confidence\"\n)\n\n# make tibble\nhd_area_predictions = hd_area_predictions$fit %&gt;% \n  as_tibble()\n\n# make toplot\nhd_toplot = bind_cols(hd_scenario,\n                      hd_area_predictions)\nhd_toplot = select(hd_toplot, c(\"fit\", \"lwr\", \"upr\",\n                                \"BuildingExposure\",\n                                \"TourismExposure\"))\nhd_toplot$area = ifelse(hd_toplot$TourismExposure == -0.6, \"Residence\",\n                        \"Tourist\")\n# plot all density\nhd_density_plot = ggplot() +\n  geom_line(data = hd_toplot,\n            aes(x = BuildingExposure,\n                y = fit,\n                colour = area),\n            alpha = 2) +\n  scale_colour_manual(values = c(\"Residence\" = \"blue\", \"Tourist\" = \"red\"),\n                      name = \"Area Type\") +\n  new_scale_colour() +\n  geom_point(data = hd_data_df,\n             aes(x = BuildingExposure,\n                 y = LST,\n                 colour = TourismExposure),\n             alpha = 0.02) +\n  scale_colour_viridis_c(name = \"Tourism Concentration\") +\n  labs(title = \"Effects of Building Concentration on Land Surface Temperature\",\n       subtitle = \"High Building Concentrations,\nMaspalomas/Playa del Inglés region of Gran Canaria\",\n       caption = \"Model Based on LandSat Imagery from 27th July 2023\",\n       x = \"Building Concentration Index\",\n       y = \"Predicted Land Surface Temperature ºC\")\n\nhd_density_plot"
  },
  {
    "objectID": "lsmodelling.html#calculating-road-heatmap",
    "href": "lsmodelling.html#calculating-road-heatmap",
    "title": "LandSat 8 Modelling",
    "section": "Calculating Road Heatmap",
    "text": "Calculating Road Heatmap\nFurthermore, there is distance from the nearest road, again calculated using OSM data.\n\n# create road raster\nroad_mask = rasterize(roads_vect,\n                      template,\n                      1,\n                      background=NA)\n\nroad_kernal = focalMat(road_mask, 100, \"Gauss\")\nroad_heat = focal(road_mask, road_kernal,\n                  fun = sum, na.rm = TRUE)\nroad_heat[is.na(road_heat)] = 0\nroad_heat = road_heat %&gt;%\n  mask(gran_canaria_vect) %&gt;%\n  scale()\n\nplot(road_heat)\nplot(gran_canaria_vect, add = TRUE)\nplot(building_vect, add = TRUE)\nmtext(text=\"Road Exposure\", side=3, line=2)"
  },
  {
    "objectID": "lsmodelling.html#calculating-tourism-exposure",
    "href": "lsmodelling.html#calculating-tourism-exposure",
    "title": "LandSat 8 Modelling",
    "section": "Calculating Tourism Exposure",
    "text": "Calculating Tourism Exposure\nFurthermore, there the effect of exposure to tourism, modelled here using a heatmap, again calculated using OSM data.\n\n# create tourism raster\ntourism_mask = rasterize(tourism_vect,\n                         template,\n                         1,\n                         background=NA)\n\n# create heatmap\ntourism_kernal = focalMat(tourism_mask, 200, \"Gauss\")\ntourism_heat = focal(tourism_mask, tourism_kernal, \n                     fun = sum, na.rm = TRUE) \ntourism_heat[is.na(tourism_heat)] = 0\ntourism_heat = tourism_heat %&gt;%\n  mask(gran_canaria_vect) %&gt;%\n  scale()\n\n# plot\nplot(tourism_heat)\nplot(gran_canaria_vect, add = TRUE)\nplot(building_vect, add = TRUE)\nmtext(text=\"Tourism Exposure\", side=3, line=2)"
  },
  {
    "objectID": "lsmodelling.html#loading-building-shapefile",
    "href": "lsmodelling.html#loading-building-shapefile",
    "title": "LandSat 8 Modelling",
    "section": "Loading Building Shapefile",
    "text": "Loading Building Shapefile\n\n# query osm\nosm_building = opq(bbox = bbox_osm) %&gt;%\n  add_osm_feature(key = \"building\") %&gt;%\n  osmdata_sf()\n\n# extract building polygons\nbuilding_vect = st_transform(osm_building$osm_polygons, crs(b1)) %&gt;%\n  vect()\n\nplot(building_vect)"
  },
  {
    "objectID": "lsmodelling.html#calculating-building-footprint-heatmap",
    "href": "lsmodelling.html#calculating-building-footprint-heatmap",
    "title": "LandSat 8 Modelling",
    "section": "Calculating Building Footprint Heatmap",
    "text": "Calculating Building Footprint Heatmap\n\n# create buidling raster\nbuilding_mask = rasterize(building_vect,\n                          template,\n                          1,\n                          background=NA)\n\n# create heatmap\nbuilding_kernal = focalMat(building_mask, 199, \"Gauss\")\nbuilding_heat = focal(building_mask, building_kernal,\n                      fun = sum, na.rm = TRUE) \nbuilding_heat[is.na(building_heat)] = 0\nbuilding_heat = building_heat %&gt;%\n  mask(gran_canaria_vect) %&gt;%\n  scale()\n\nplot(building_heat)\nplot(gran_canaria_vect, add = TRUE)\nplot(building_vect, add = TRUE)\nmtext(text=\"Building Concentration\", side=3, line=2)"
  },
  {
    "objectID": "index.html#libraries",
    "href": "index.html#libraries",
    "title": "Jody Holland Thesis",
    "section": "Libraries",
    "text": "Libraries\nThis methodology will use the following R packages for data wrangling using data from July 24th 2023 (a day when both Sentinel and Landsat imagery coincides).\n\nThe tidyverse family of packages (Wickham et al. 2019), which includes\n\ndplyr for wrangling data (Wickham et al. 2023)\ntidyr for managing data sets (Wickham, Vaughan, and Girlich 2024)\nggplot2 for visualisations (Wickham 2016)\n\nThe terra package for handling raster data (Hijmans 2024)\nThe RColorBrewer package for colour scales (Neuwirth 2022)\nThe sf package for handling shapefile data (Pebesma and Bivand 2023)\nThe leaflet package for interactive visualisation (Cheng et al. 2023)\nThe osmdata package for extracting coastline data (Massicotte and South 2023)\nThe modelsummary package for outputting regression results (Arel-Bundock 2022)\nThe ggnewscale package for help with layered plots (Campitelli 2024)"
  },
  {
    "objectID": "lsjuly.html",
    "href": "lsjuly.html",
    "title": "LandSat 8 July",
    "section": "",
    "text": "Here the LST and NDVI from LandSat 8 at 30m resolution is calculated for July 2023. This is in a similar process to Onačillová et al. (2022); Equere et al. (2021); Son et al. (2017); Karyati et al. (2022).\n\n# load packages\nlibrary(tidyverse)\nlibrary(terra)\nlibrary(RColorBrewer)\nlibrary(sf)\nlibrary(leaflet)\nlibrary(osmdata)\n\n\n\nThese rasters denote different bands of EM radiation captured by the LandSat 8 satellite over the south of Gran Canaria at 11:29am on the 24th July 2023 (U. S. Geological Surey 2023). These bands cover most of the visible light spectrum as well as the infrared spectrum. Combined in various was they can be used to calculate various measures such as the NDVI (normalised difference vegetation index) and the LST (land surface temperature).\nFirst lets plot and load the rasters\n\n# function to plot raster with a label and custome colour scale\nplot_rast = function(raster, label, colors) {\n  terra::plot(raster, col=colorRampPalette(colors)(100))\n  mtext(text=label, side=3, line=2)\n}\n\n# define the bounding box epsg:4083\nbbox = ext(c(437292.6282,445376.8775,3067829.6809,3072637.1023))\n\n# load each raster, crop to bounding box, and plot with label\nb2 = crop(rast(\"landsat_july/B2.TIF\"), bbox)\nb3 = crop(rast(\"landsat_july/B3.TIF\"), bbox)\nb4 = crop(rast(\"landsat_july/B4.TIF\"), bbox)\nb5 = crop(rast(\"landsat_july/B5.TIF\"), bbox)\nb6 = crop(rast(\"landsat_july/B6.TIF\"), bbox)\nb7 = crop(rast(\"landsat_july/B7.TIF\"), bbox)\nb10 = crop(rast(\"landsat_july/B10.TIF\"), bbox)\n\n\n\n\nUsing OSM Data to first extract a coastline of the island\n\n# query osm\ngran_canaria_query = opq(bbox = \"Gran Canaria\") %&gt;%\n  add_osm_feature(key = \"place\", value = \"island\") %&gt;%\n  osmdata_sf()\n# extract the coast data\ngran_canaria_sf = gran_canaria_query$osm_multipolygons\n\n# make spatial vector\ngran_canaria_vect = st_transform(gran_canaria_sf, crs(b2)) %&gt;%\n  vect()\n\n\n\n\n\nb2 = mask(b2, gran_canaria_vect)\nb3 = mask(b3, gran_canaria_vect)\nb4 = mask(b4, gran_canaria_vect)\nb5 = mask(b5, gran_canaria_vect)\nb6 = mask(b6, gran_canaria_vect)\nb7 = mask(b7, gran_canaria_vect)\nb10 = mask(b10, gran_canaria_vect)\n\n\n\n\nPerhaps the most important metric beside LST is NVDI. NDVI is also used in the computation of impassivity and ultimately therefore emissivity adjusted LST.\nTo calculate NDVI, the following formula is used:\n\\[\n\\text{NDVI} = \\frac{\\text{NIR} - \\text{Red}}{\\text{NIR} + \\text{Red}}\n\\]\nHere \\(NIR\\) represents the Near-Infrared band reflectance value, in Landsat 8 this is Band 5. Further \\(Red\\) represents the Red band reflectance value, in Landsat 8 this is Band 4.\n\n# calc and plot ndvi using bands 5 and 4\nndvi = (b5-b4)/(b5+b4)\n\nplot_rast(ndvi,\n          \"Normalised Difference Vegetation Index (NDVI)\",\n          c(\"brown\", \"green\"))\n\n\n\n\n\n\n\nAnother important metric is NDBI as urban artificial surfaces may trap heat causing excess heating relative to vegetated surfaces.\nTo calculate NDBI for Landsat 8, the following formula is used (Abulibdeh 2021):\n\\[\n\\text{NDVI} = \\frac{\\text{MIR} - \\text{NIR}}{\\text{MIR} + \\text{NIR}}\n\\]\nHere \\(NIR\\) again represents the Middle-Infrared band value, in Landsat 8 this is Band 5. Also \\(NIR\\) again represents the Near-Infrared band value, being Landsat 8 Band 5.\nHowever, we may not use this as for arid areas it has reduced efficacy. Instead we may rasterise OSM building data.\n\nndbi = (b6-b5)/(b6+b5)\n\nplot_rast(ndbi,\n          \"Normalised Difference Built Index (NDBI)\",\n          c(\"lightgreen\", \"black\"))\n\n\n\n\n\n\n\nComplementing these metrics is NDWI, here used to analyse the impact that surface water has upon the temperature.\nTo calculate NWBI for Landsat 8, the following formula is used:\n\\[\n\\text{NDVI} = \\frac{\\text{Green} - \\text{SWIR}}{\\text{Green} + \\text{SWIR}}\n\\]\nHere \\(Green\\) represents the Green reflectance values, in Landsat 8 this is Band 3. Also \\(SWIR\\) again represents the Short-Infrared band value, being Landsat 8 Band 7.\n\n# calc and plot\nndwi = (b3-b7)/(b3+b7)\n\nplot_rast(ndwi,\n          \"Normalised Difference Water Index (NDWI)\",\n          c(\"yellow\", \"blue\"))\n\n\n\n\n\n\n\nThere is also surface albedo \\(\\alpha\\), which is the the fraction of the reflected shortwave radiation, is calculated using the following formula (Equere et al. 2021):\n\\[\n\\alpha = \\frac{0.356·\\text{Blue} + 0.0130 · \\text{Red} + 0.373 · \\text{NIR} + 0.085 * \\text{MIR} + 0.072 · \\text{SWIR} - 0.0018}{1.016}\n\\]\nHere \\(Blue\\) represents the Blue reflectance values, in Landsat 8 this is Band 2. \\(Red\\) again represents the Red band value, being Landsat 8 Band 4. \\(NIR\\) represents the Near-Infrared values, in Landsat 8 this is Band 5. \\(MIR\\) likewise represents the Middle-Infrared values, being Landsat 8 Band 6. Finally \\(SWIR\\) represents the Near-Infrared values, in Landsat 8 this is Band 7.\n\n# calc and plot\nalbedo = (0.356*b2+0.0130*b4+0.373*b5+0.085*b6+0.072*b7-0.0018)/1.016\n\nplot_rast(albedo,\n          expression(paste(\"Surface Albedo (\", alpha,\")\")),\n          c(\"pink\", \"blue\"))\n\n\n\n\n\n\n\nCalculating LST can be straightforward in principle, using Band 10 alone of Landsat 8 data. However, this will not account for surface emissivity. Thus, for this study, an adjusted LST is calculated.\n\n\nThe first step is to convert the Digital Numbers \\(DN\\) in the Band 10 layer to Top of Atmosphere Spectral Radiance \\(L_\\lambda\\) values. This process uses input units found the images metadata/MLT file. These values are the RADIANCE_MULT_BAND_10 \\(M_L\\) and the RADIANCE_ADD_BAND_10 \\(\\text{A}_L\\).\nPutting these together into a formula is as follows:\n\\[\n\\text{L}_\\lambda = \\text{M}_L · \\text{DN} + \\text{A}_L\n\\]\n\n# define metadata values\nmult_b10 = 3.8e-04\nadd_b10 = 0.1\n\n# calc and plot\nl = (mult_b10*b10+add_b10)\n\nplot_rast(l,\n          expression(Spectral~Radiance~(L[lambda])),\n          c(\"brown\", \"yellow\"))\n\n\n\n\n\n\n\nThe second step is “Conversion of Radiance to At-Sensor Temperature” (Karyati et al. 2022). This This converts the Spectral Radiance into temperature values or Brightness Temperature \\(BT\\) in Kelvin. This process requires two constants related to Landsat 8 Band 10’s specific thermal conversion constants found again in the metadata file. These are \\(K1\\)and \\(K2\\).\nPutting this together into a formula is as follows:\n\\[\n\\text{BT} = \\frac{\\text{K2}}{ln(\\frac{\\text{K1}}{\\text{L}_\\lambda} + 1)}\n\\]\n\n# add effective wavelength of landsat b10\nk1 = 799.0284\nk2 = 1329.2405\n\n# calc and plot\nbt = (k2/log(k1/l+1))\n\nplot_rast(bt,\n          expression(Brightness~Temp~(BT)),\n          c(\"blue\", \"red\")) \n\n\n\n\n\n\n\nThe above metric alone could be used for study of heat distribution, however it does not account for the variation caused by surface level emissivity. Emissivity denotes how much infrared a surface will absorb or reflect, ranging from a mirror to a perfect black surface. The values of emissivity range from 0 to 1 respectively.\n\n\nNDVI is used to determine emissivity, through the fractional vegetation factor \\(\\text{P}_v\\). This value is specific to the region being studied.\nThe formula for calculating fractional vegetation factor is as follows:\n\\[\n\\text{P}_v = \\left( \\frac{\\text{NDVI} - \\text{NDVI}_{\\min}}{\\text{NDVI}_{\\max} - \\text{NDVI}_{\\min}} \\right)^2\n\\]\n\n# define min and max ndvi\nmin_ndvi = global(ndvi, fun=min, na.rm=TRUE) %&gt;%\n  as.numeric()\nmax_ndvi = global(ndvi, fun=max, na.rm=TRUE) %&gt;%\n  as.numeric()\n\n# calc and plot vegetation factor\npv = ((ndvi-min_ndvi)/(max_ndvi-min_ndvi))^2\n\nplot_rast(pv,\n          expression(Fractional~Vegetation~Factor~(P[v])),\n          c(\"maroon\", \"green\"))\n\n\n\n\n\n\n\nFrom this the surface emissivity can be calculated. This uses two constants relating to the relative emissivity of soil \\(\\epsilon\\text{s}\\lambda\\) and the emissivity of vegetation \\(\\epsilon\\text{v}\\lambda\\), as well as one surface roughness \\(\\text{C}\\lambda\\) metric of 0.005\nThe formula for estimating emissivity \\(\\epsilon\\lambda\\) is thus as follows:\n\\[\n\\epsilon\\lambda = \\epsilon\\text{v}\\lambda + \\epsilon\\text{s}\\lambda  · (1 - \\text{P}_v) + \\text{C}\\lambda\n\\]\n\n# soil emissivity\nes = 0.964\n\n# veg emissivity\nev = 0.984\n\n# calc and plot emissivity\ne =  ev*pv+es*(1-pv)+0.005\n\nplot_rast(e,\n          expression(Emissivity~(epsilon*lambda)),\n          c(\"yellow\", \"darkgreen\"))\n\n\n\n\n\n\n\n\nNow most of the building blocks are in place to calculate the adjusted LST. This requires a correction constant \\(\\rho\\) that incorporates the Speed of Light \\(c\\), Planck’s constant \\(h\\), and Boltzmann’s constant \\(\\sigma\\).\nThe formula for this is as follows:\n\\[\n\\rho = \\frac{c·h}{\\sigma}\n\\]\n\n# speed of light\nc = 2.997925e8 \n\n# planck's constant\nh = 6.626070e-34\n\n# boltzmann's constant\nsigma = 1.380649e-23\n\n# calc and output correction constant/rho \nrho = c*h/sigma\nrho\n\n[1] 0.01438777\n\n\n\n\n\nWith these building blocks, plus the wavelength of the emitted radiance for Landsat 8 \\(\\lambda\\), the adjusted LST \\(\\text{T}s\\) can be determined using the following formula (converting from Kelvin to Celcius:\n\\[\n\\text{T}_s = \\frac{\\text{BT}}{1 + (\\frac{\\lambda\\text{BT}}{\\rho} · ln(\\epsilon\\lambda))} - 273.15\n\\]\n\n# wavelength\nwl = 10.895e-6\n\n# calc and plot\nts = bt/(1+(wl*bt/rho)*log(e))-273.15\n\nplot_rast(ts,\n          expression(Land~Surface~Temperature~(T[s])), c(\"blue\", \"red\"))\n\n\n\n\n\n\nUsing the Leaflet Package for R (Cheng et al. 2023), we can visualise the resulting rast\n\nplet(ts,\n     col=(c(\"darkblue\",\"pink\")),\n     legend=\"bottomright\",\n     main=\"LST (Cº)\",\n     tiles=c(\"Esri.WorldImagery\"))\n\n\n\n\n\n\n\n\n\n\nExport July data as a csv\n\nstack = c(ndvi, ndbi, ndwi, albedo, ts)\n\ndata_df = na.omit(as.data.frame(stack, xy=TRUE))\n\ndata_df$month = \"july\"\n\nnames(data_df) = c(\"X\", \"Y\", \n                   \"NDVI\",\"NDBI\",\n                   \"NDWI\", \"Albedo\", \"TS\",\n                   \"Month\")\n\nwrite_csv(data_df, \"july.csv\")"
  },
  {
    "objectID": "lsjuly.html#loading-rasters",
    "href": "lsjuly.html#loading-rasters",
    "title": "LandSat 8 July",
    "section": "",
    "text": "These rasters denote different bands of EM radiation captured by the LandSat 8 satellite over the south of Gran Canaria at 11:29am on the 24th July 2023 (U. S. Geological Surey 2023). These bands cover most of the visible light spectrum as well as the infrared spectrum. Combined in various was they can be used to calculate various measures such as the NDVI (normalised difference vegetation index) and the LST (land surface temperature).\nFirst lets plot and load the rasters\n\n# function to plot raster with a label and custome colour scale\nplot_rast = function(raster, label, colors) {\n  terra::plot(raster, col=colorRampPalette(colors)(100))\n  mtext(text=label, side=3, line=2)\n}\n\n# define the bounding box epsg:4083\nbbox = ext(c(437292.6282,445376.8775,3067829.6809,3072637.1023))\n\n# load each raster, crop to bounding box, and plot with label\nb2 = crop(rast(\"landsat_july/B2.TIF\"), bbox)\nb3 = crop(rast(\"landsat_july/B3.TIF\"), bbox)\nb4 = crop(rast(\"landsat_july/B4.TIF\"), bbox)\nb5 = crop(rast(\"landsat_july/B5.TIF\"), bbox)\nb6 = crop(rast(\"landsat_july/B6.TIF\"), bbox)\nb7 = crop(rast(\"landsat_july/B7.TIF\"), bbox)\nb10 = crop(rast(\"landsat_july/B10.TIF\"), bbox)"
  },
  {
    "objectID": "lsjuly.html#loading-coast-shapefile",
    "href": "lsjuly.html#loading-coast-shapefile",
    "title": "LandSat 8 July",
    "section": "",
    "text": "Using OSM Data to first extract a coastline of the island\n\n# query osm\ngran_canaria_query = opq(bbox = \"Gran Canaria\") %&gt;%\n  add_osm_feature(key = \"place\", value = \"island\") %&gt;%\n  osmdata_sf()\n# extract the coast data\ngran_canaria_sf = gran_canaria_query$osm_multipolygons\n\n# make spatial vector\ngran_canaria_vect = st_transform(gran_canaria_sf, crs(b2)) %&gt;%\n  vect()"
  },
  {
    "objectID": "lsjuly.html#masking-ocean-values",
    "href": "lsjuly.html#masking-ocean-values",
    "title": "LandSat 8 July",
    "section": "",
    "text": "b2 = mask(b2, gran_canaria_vect)\nb3 = mask(b3, gran_canaria_vect)\nb4 = mask(b4, gran_canaria_vect)\nb5 = mask(b5, gran_canaria_vect)\nb6 = mask(b6, gran_canaria_vect)\nb7 = mask(b7, gran_canaria_vect)\nb10 = mask(b10, gran_canaria_vect)"
  },
  {
    "objectID": "lsjuly.html#calculating-ndvi",
    "href": "lsjuly.html#calculating-ndvi",
    "title": "LandSat 8 July",
    "section": "",
    "text": "Perhaps the most important metric beside LST is NVDI. NDVI is also used in the computation of impassivity and ultimately therefore emissivity adjusted LST.\nTo calculate NDVI, the following formula is used:\n\\[\n\\text{NDVI} = \\frac{\\text{NIR} - \\text{Red}}{\\text{NIR} + \\text{Red}}\n\\]\nHere \\(NIR\\) represents the Near-Infrared band reflectance value, in Landsat 8 this is Band 5. Further \\(Red\\) represents the Red band reflectance value, in Landsat 8 this is Band 4.\n\n# calc and plot ndvi using bands 5 and 4\nndvi = (b5-b4)/(b5+b4)\n\nplot_rast(ndvi,\n          \"Normalised Difference Vegetation Index (NDVI)\",\n          c(\"brown\", \"green\"))"
  },
  {
    "objectID": "lsjuly.html#calculating-ndbi",
    "href": "lsjuly.html#calculating-ndbi",
    "title": "LandSat 8 July",
    "section": "",
    "text": "Another important metric is NDBI as urban artificial surfaces may trap heat causing excess heating relative to vegetated surfaces.\nTo calculate NDBI for Landsat 8, the following formula is used (Abulibdeh 2021):\n\\[\n\\text{NDVI} = \\frac{\\text{MIR} - \\text{NIR}}{\\text{MIR} + \\text{NIR}}\n\\]\nHere \\(NIR\\) again represents the Middle-Infrared band value, in Landsat 8 this is Band 5. Also \\(NIR\\) again represents the Near-Infrared band value, being Landsat 8 Band 5.\nHowever, we may not use this as for arid areas it has reduced efficacy. Instead we may rasterise OSM building data.\n\nndbi = (b6-b5)/(b6+b5)\n\nplot_rast(ndbi,\n          \"Normalised Difference Built Index (NDBI)\",\n          c(\"lightgreen\", \"black\"))"
  },
  {
    "objectID": "lsjuly.html#calculating-ndwi",
    "href": "lsjuly.html#calculating-ndwi",
    "title": "LandSat 8 July",
    "section": "",
    "text": "Complementing these metrics is NDWI, here used to analyse the impact that surface water has upon the temperature.\nTo calculate NWBI for Landsat 8, the following formula is used:\n\\[\n\\text{NDVI} = \\frac{\\text{Green} - \\text{SWIR}}{\\text{Green} + \\text{SWIR}}\n\\]\nHere \\(Green\\) represents the Green reflectance values, in Landsat 8 this is Band 3. Also \\(SWIR\\) again represents the Short-Infrared band value, being Landsat 8 Band 7.\n\n# calc and plot\nndwi = (b3-b7)/(b3+b7)\n\nplot_rast(ndwi,\n          \"Normalised Difference Water Index (NDWI)\",\n          c(\"yellow\", \"blue\"))"
  },
  {
    "objectID": "lsjuly.html#calculating-surface-albedo",
    "href": "lsjuly.html#calculating-surface-albedo",
    "title": "LandSat 8 July",
    "section": "",
    "text": "There is also surface albedo \\(\\alpha\\), which is the the fraction of the reflected shortwave radiation, is calculated using the following formula (Equere et al. 2021):\n\\[\n\\alpha = \\frac{0.356·\\text{Blue} + 0.0130 · \\text{Red} + 0.373 · \\text{NIR} + 0.085 * \\text{MIR} + 0.072 · \\text{SWIR} - 0.0018}{1.016}\n\\]\nHere \\(Blue\\) represents the Blue reflectance values, in Landsat 8 this is Band 2. \\(Red\\) again represents the Red band value, being Landsat 8 Band 4. \\(NIR\\) represents the Near-Infrared values, in Landsat 8 this is Band 5. \\(MIR\\) likewise represents the Middle-Infrared values, being Landsat 8 Band 6. Finally \\(SWIR\\) represents the Near-Infrared values, in Landsat 8 this is Band 7.\n\n# calc and plot\nalbedo = (0.356*b2+0.0130*b4+0.373*b5+0.085*b6+0.072*b7-0.0018)/1.016\n\nplot_rast(albedo,\n          expression(paste(\"Surface Albedo (\", alpha,\")\")),\n          c(\"pink\", \"blue\"))"
  },
  {
    "objectID": "lsjuly.html#calculating-lst",
    "href": "lsjuly.html#calculating-lst",
    "title": "LandSat 8 July",
    "section": "",
    "text": "Calculating LST can be straightforward in principle, using Band 10 alone of Landsat 8 data. However, this will not account for surface emissivity. Thus, for this study, an adjusted LST is calculated.\n\n\nThe first step is to convert the Digital Numbers \\(DN\\) in the Band 10 layer to Top of Atmosphere Spectral Radiance \\(L_\\lambda\\) values. This process uses input units found the images metadata/MLT file. These values are the RADIANCE_MULT_BAND_10 \\(M_L\\) and the RADIANCE_ADD_BAND_10 \\(\\text{A}_L\\).\nPutting these together into a formula is as follows:\n\\[\n\\text{L}_\\lambda = \\text{M}_L · \\text{DN} + \\text{A}_L\n\\]\n\n# define metadata values\nmult_b10 = 3.8e-04\nadd_b10 = 0.1\n\n# calc and plot\nl = (mult_b10*b10+add_b10)\n\nplot_rast(l,\n          expression(Spectral~Radiance~(L[lambda])),\n          c(\"brown\", \"yellow\"))\n\n\n\n\n\n\n\nThe second step is “Conversion of Radiance to At-Sensor Temperature” (Karyati et al. 2022). This This converts the Spectral Radiance into temperature values or Brightness Temperature \\(BT\\) in Kelvin. This process requires two constants related to Landsat 8 Band 10’s specific thermal conversion constants found again in the metadata file. These are \\(K1\\)and \\(K2\\).\nPutting this together into a formula is as follows:\n\\[\n\\text{BT} = \\frac{\\text{K2}}{ln(\\frac{\\text{K1}}{\\text{L}_\\lambda} + 1)}\n\\]\n\n# add effective wavelength of landsat b10\nk1 = 799.0284\nk2 = 1329.2405\n\n# calc and plot\nbt = (k2/log(k1/l+1))\n\nplot_rast(bt,\n          expression(Brightness~Temp~(BT)),\n          c(\"blue\", \"red\")) \n\n\n\n\n\n\n\nThe above metric alone could be used for study of heat distribution, however it does not account for the variation caused by surface level emissivity. Emissivity denotes how much infrared a surface will absorb or reflect, ranging from a mirror to a perfect black surface. The values of emissivity range from 0 to 1 respectively.\n\n\nNDVI is used to determine emissivity, through the fractional vegetation factor \\(\\text{P}_v\\). This value is specific to the region being studied.\nThe formula for calculating fractional vegetation factor is as follows:\n\\[\n\\text{P}_v = \\left( \\frac{\\text{NDVI} - \\text{NDVI}_{\\min}}{\\text{NDVI}_{\\max} - \\text{NDVI}_{\\min}} \\right)^2\n\\]\n\n# define min and max ndvi\nmin_ndvi = global(ndvi, fun=min, na.rm=TRUE) %&gt;%\n  as.numeric()\nmax_ndvi = global(ndvi, fun=max, na.rm=TRUE) %&gt;%\n  as.numeric()\n\n# calc and plot vegetation factor\npv = ((ndvi-min_ndvi)/(max_ndvi-min_ndvi))^2\n\nplot_rast(pv,\n          expression(Fractional~Vegetation~Factor~(P[v])),\n          c(\"maroon\", \"green\"))\n\n\n\n\n\n\n\nFrom this the surface emissivity can be calculated. This uses two constants relating to the relative emissivity of soil \\(\\epsilon\\text{s}\\lambda\\) and the emissivity of vegetation \\(\\epsilon\\text{v}\\lambda\\), as well as one surface roughness \\(\\text{C}\\lambda\\) metric of 0.005\nThe formula for estimating emissivity \\(\\epsilon\\lambda\\) is thus as follows:\n\\[\n\\epsilon\\lambda = \\epsilon\\text{v}\\lambda + \\epsilon\\text{s}\\lambda  · (1 - \\text{P}_v) + \\text{C}\\lambda\n\\]\n\n# soil emissivity\nes = 0.964\n\n# veg emissivity\nev = 0.984\n\n# calc and plot emissivity\ne =  ev*pv+es*(1-pv)+0.005\n\nplot_rast(e,\n          expression(Emissivity~(epsilon*lambda)),\n          c(\"yellow\", \"darkgreen\"))\n\n\n\n\n\n\n\n\nNow most of the building blocks are in place to calculate the adjusted LST. This requires a correction constant \\(\\rho\\) that incorporates the Speed of Light \\(c\\), Planck’s constant \\(h\\), and Boltzmann’s constant \\(\\sigma\\).\nThe formula for this is as follows:\n\\[\n\\rho = \\frac{c·h}{\\sigma}\n\\]\n\n# speed of light\nc = 2.997925e8 \n\n# planck's constant\nh = 6.626070e-34\n\n# boltzmann's constant\nsigma = 1.380649e-23\n\n# calc and output correction constant/rho \nrho = c*h/sigma\nrho\n\n[1] 0.01438777\n\n\n\n\n\nWith these building blocks, plus the wavelength of the emitted radiance for Landsat 8 \\(\\lambda\\), the adjusted LST \\(\\text{T}s\\) can be determined using the following formula (converting from Kelvin to Celcius:\n\\[\n\\text{T}_s = \\frac{\\text{BT}}{1 + (\\frac{\\lambda\\text{BT}}{\\rho} · ln(\\epsilon\\lambda))} - 273.15\n\\]\n\n# wavelength\nwl = 10.895e-6\n\n# calc and plot\nts = bt/(1+(wl*bt/rho)*log(e))-273.15\n\nplot_rast(ts,\n          expression(Land~Surface~Temperature~(T[s])), c(\"blue\", \"red\"))\n\n\n\n\n\n\nUsing the Leaflet Package for R (Cheng et al. 2023), we can visualise the resulting rast\n\nplet(ts,\n     col=(c(\"darkblue\",\"pink\")),\n     legend=\"bottomright\",\n     main=\"LST (Cº)\",\n     tiles=c(\"Esri.WorldImagery\"))"
  },
  {
    "objectID": "lsjuly.html#stack-and-export",
    "href": "lsjuly.html#stack-and-export",
    "title": "LandSat 8 July",
    "section": "",
    "text": "Export July data as a csv\n\nstack = c(ndvi, ndbi, ndwi, albedo, ts)\n\ndata_df = na.omit(as.data.frame(stack, xy=TRUE))\n\ndata_df$month = \"july\"\n\nnames(data_df) = c(\"X\", \"Y\", \n                   \"NDVI\",\"NDBI\",\n                   \"NDWI\", \"Albedo\", \"TS\",\n                   \"Month\")\n\nwrite_csv(data_df, \"july.csv\")"
  },
  {
    "objectID": "control_variables.html",
    "href": "control_variables.html",
    "title": "Control Variables",
    "section": "",
    "text": "Here the various control variables are determined\n\n# load packages\nlibrary(tidyverse)\nlibrary(terra)\nlibrary(RColorBrewer)\nlibrary(sf)\nlibrary(leaflet)\nlibrary(osmdata)\n\n\n\nThe first step is to load one Landsat 8 raster for extracting the CRS which will be needed for formatting the data from OSM and other sources like the STRM elevation map.\n\n# load one raster, for use as crs\nb2 = rast(\"landsat_july/B2.TIF\")\n\n\n\nUsing OSM Data to first extract a coastline of the island, this process enables such analysis as calculating distance from the coastline\n\n# query osm\ngran_canaria_query = opq(bbox = \"Gran Canaria\") %&gt;%\n  add_osm_feature(key = \"place\", value = \"island\") %&gt;%\n  osmdata_sf()\n# extract the coast data\ngran_canaria_sf = gran_canaria_query$osm_multipolygons\n\n# make spatial vector\ngran_canaria_vect = st_transform(gran_canaria_sf, crs(b2)) %&gt;%\n  vect()\n\n\n\n\nAgain using OSM data, it is possible to extract road data in the form of a spatial vector.\n\n# define bbox\nbbox_osm = c(-15.636205673397361,\n             27.73337624747081,\n             -15.554409027542757,\n             27.777126576546703)\n\n# query osm\nosm_roads = opq(bbox = bbox_osm) %&gt;%\n  add_osm_feature(key = \"highway\") %&gt;%\n  osmdata_sf()\n\n# extract road lines\nroads_vect = st_transform(osm_roads$osm_lines, crs(b2)) %&gt;%\n  vect()\n\n\n\n\n\n# query osm\nosm_tourism = opq(bbox = bbox_osm) %&gt;%\n  add_osm_feature(key = \"tourism\") %&gt;%\n  osmdata_sf()\n\n# extract tourism points\ntourism_vect = st_transform(osm_tourism$osm_points, crs(b2)) %&gt;%\n  vect()\n\nplot(tourism_vect)\n\n\n\n\n\n\n\n\n# query osm\nosm_building = opq(bbox = bbox_osm) %&gt;%\n  add_osm_feature(key = \"building\") %&gt;%\n  osmdata_sf()\n\n# extract building polygons\nbuilding_vect = st_transform(osm_building$osm_polygons, crs(b2)) %&gt;%\n  vect()\n\nplot(building_vect)\n\n\n\n\n\n\n\n\nIn terms of other environmental variables, there is also distance from the coast to consider, calculated using OSM coastline data.\n\n# create blank template\nbbox = ext(c(437292.6282,445376.8775,3067829.6809,3072637.1023))\ntemplate = crop(rast(\"landsat_july/B1.TIF\"), bbox)\n\n# crop sp by bbox\ngran_canaria_vect = crop(gran_canaria_vect, bbox)\n\n# create land raster\nsea_mask = rasterize(gran_canaria_vect,\n                      template,\n                      NA,\n                      background=1)\n\n\n# calc distance and plot\ncoastdistance = distance(sea_mask) %&gt;%\n  mask(gran_canaria_vect) / 1000\nterra::plot(coastdistance, col = hcl.colors(100))\nplot(gran_canaria_vect, add = TRUE)\nmtext(text=\"Coastal Distance (km)\", side=3, line=2)\n\n\n\n\n\n\n\nFurthermore, there is distance from the nearest road, again calculated using OSM data.\n\n# create road raster\nroad_mask = rasterize(roads_vect,\n                      template,\n                      1,\n                      background=NA)\n\nroad_kernal = focalMat(road_mask, 100, \"Gauss\")\nroad_heat = focal(road_mask, road_kernal,\n                  fun = sum, na.rm = TRUE)\nroad_heat[is.na(road_heat)] = 0\nroad_heat = road_heat %&gt;%\n  mask(gran_canaria_vect) %&gt;%\n  scale()\n\nplot(road_heat)\nplot(gran_canaria_vect, add = TRUE)\nplot(building_vect, add = TRUE)\nmtext(text=\"Road Exposure\", side=3, line=2)\n\n\n\n\n\n\n\nFurthermore, there the effect of exposure to tourism, modelled here using a heatmap, again calculated using OSM data.\n\n# create tourism raster\ntourism_mask = rasterize(tourism_vect,\n                         template,\n                         1,\n                         background=NA)\n\n# create heatmap\ntourism_kernal = focalMat(tourism_mask, 200, \"Gauss\")\ntourism_heat = focal(tourism_mask, tourism_kernal, \n                     fun = sum, na.rm = TRUE) \ntourism_heat[is.na(tourism_heat)] = 0\ntourism_heat = tourism_heat %&gt;%\n  mask(gran_canaria_vect) %&gt;%\n  scale()\n\n# plot\nplot(tourism_heat)\nplot(gran_canaria_vect, add = TRUE)\nplot(building_vect, add = TRUE)\nmtext(text=\"Tourism Exposure\", side=3, line=2)\n\n\n\n\n\n\n\n\n# create buidling raster\nbuilding_mask = rasterize(building_vect,\n                          template,\n                          1,\n                          background=NA)\n\n# create heatmap\nbuilding_kernal = focalMat(building_mask, 199, \"Gauss\")\nbuilding_heat = focal(building_mask, building_kernal,\n                      fun = sum, na.rm = TRUE) \nbuilding_heat[is.na(building_heat)] = 0\nbuilding_heat = building_heat %&gt;%\n  mask(gran_canaria_vect) %&gt;%\n  scale()\n\nplot(building_heat)\nplot(gran_canaria_vect, add = TRUE)\nplot(building_vect, add = TRUE)\nmtext(text=\"Building Concentration\", side=3, line=2)\n\n\n\n\n\n\n\nLoad in 30m resolution from STRM project. The processing steps here are just to plot and visualise it with a custom colour scale.\n\n# load elevation raster, resample, and crop\nstrm = rast(\"strm/strm.tif\") %&gt;% \n  project(crs(b2)) %&gt;%\n  resample(b2, method = \"bilinear\") %&gt;%\n  crop(bbox) %&gt;%\n  mask(gran_canaria_vect)\n\n# plot\nplot(strm)\nplot(gran_canaria_vect, add = TRUE)\nplot(building_vect, add = TRUE)\nmtext(text=\"Elevation (m)\", side=3, line=2)\n\n\n\n\n\n\n\n\ncontrol_stack = c(coastdistance, tourism_heat, building_heat,\n                  road_heat, strm)\n\ndata_df = na.omit(as.data.frame(control_stack, xy=TRUE))\n\nnames(data_df) = c(\"X\", \"Y\", \n                   \"CoastDistance\",\"TourismExposure\",\n                   \"BuildingExposure\", \"RoadExposure\", \"Elevation\")\n\nwrite_csv(data_df, \"control_variables.csv\")"
  },
  {
    "objectID": "control_variables.html#loading-data",
    "href": "control_variables.html#loading-data",
    "title": "Control Variables",
    "section": "",
    "text": "The first step is to load one Landsat 8 raster for extracting the CRS which will be needed for formatting the data from OSM and other sources like the STRM elevation map.\n\n# load one raster, for use as crs\nb2 = rast(\"landsat_july/B2.TIF\")\n\n\n\nUsing OSM Data to first extract a coastline of the island, this process enables such analysis as calculating distance from the coastline\n\n# query osm\ngran_canaria_query = opq(bbox = \"Gran Canaria\") %&gt;%\n  add_osm_feature(key = \"place\", value = \"island\") %&gt;%\n  osmdata_sf()\n# extract the coast data\ngran_canaria_sf = gran_canaria_query$osm_multipolygons\n\n# make spatial vector\ngran_canaria_vect = st_transform(gran_canaria_sf, crs(b2)) %&gt;%\n  vect()\n\n\n\n\nAgain using OSM data, it is possible to extract road data in the form of a spatial vector.\n\n# define bbox\nbbox_osm = c(-15.636205673397361,\n             27.73337624747081,\n             -15.554409027542757,\n             27.777126576546703)\n\n# query osm\nosm_roads = opq(bbox = bbox_osm) %&gt;%\n  add_osm_feature(key = \"highway\") %&gt;%\n  osmdata_sf()\n\n# extract road lines\nroads_vect = st_transform(osm_roads$osm_lines, crs(b2)) %&gt;%\n  vect()\n\n\n\n\n\n# query osm\nosm_tourism = opq(bbox = bbox_osm) %&gt;%\n  add_osm_feature(key = \"tourism\") %&gt;%\n  osmdata_sf()\n\n# extract tourism points\ntourism_vect = st_transform(osm_tourism$osm_points, crs(b2)) %&gt;%\n  vect()\n\nplot(tourism_vect)\n\n\n\n\n\n\n\n\n# query osm\nosm_building = opq(bbox = bbox_osm) %&gt;%\n  add_osm_feature(key = \"building\") %&gt;%\n  osmdata_sf()\n\n# extract building polygons\nbuilding_vect = st_transform(osm_building$osm_polygons, crs(b2)) %&gt;%\n  vect()\n\nplot(building_vect)"
  },
  {
    "objectID": "control_variables.html#calculating-distance-from-ocean",
    "href": "control_variables.html#calculating-distance-from-ocean",
    "title": "Control Variables",
    "section": "",
    "text": "In terms of other environmental variables, there is also distance from the coast to consider, calculated using OSM coastline data.\n\n# create blank template\nbbox = ext(c(437292.6282,445376.8775,3067829.6809,3072637.1023))\ntemplate = crop(rast(\"landsat_july/B1.TIF\"), bbox)\n\n# crop sp by bbox\ngran_canaria_vect = crop(gran_canaria_vect, bbox)\n\n# create land raster\nsea_mask = rasterize(gran_canaria_vect,\n                      template,\n                      NA,\n                      background=1)\n\n\n# calc distance and plot\ncoastdistance = distance(sea_mask) %&gt;%\n  mask(gran_canaria_vect) / 1000\nterra::plot(coastdistance, col = hcl.colors(100))\nplot(gran_canaria_vect, add = TRUE)\nmtext(text=\"Coastal Distance (km)\", side=3, line=2)"
  },
  {
    "objectID": "control_variables.html#calculating-road-heatmap",
    "href": "control_variables.html#calculating-road-heatmap",
    "title": "Control Variables",
    "section": "",
    "text": "Furthermore, there is distance from the nearest road, again calculated using OSM data.\n\n# create road raster\nroad_mask = rasterize(roads_vect,\n                      template,\n                      1,\n                      background=NA)\n\nroad_kernal = focalMat(road_mask, 100, \"Gauss\")\nroad_heat = focal(road_mask, road_kernal,\n                  fun = sum, na.rm = TRUE)\nroad_heat[is.na(road_heat)] = 0\nroad_heat = road_heat %&gt;%\n  mask(gran_canaria_vect) %&gt;%\n  scale()\n\nplot(road_heat)\nplot(gran_canaria_vect, add = TRUE)\nplot(building_vect, add = TRUE)\nmtext(text=\"Road Exposure\", side=3, line=2)"
  },
  {
    "objectID": "control_variables.html#calculating-tourism-exposure",
    "href": "control_variables.html#calculating-tourism-exposure",
    "title": "Control Variables",
    "section": "",
    "text": "Furthermore, there the effect of exposure to tourism, modelled here using a heatmap, again calculated using OSM data.\n\n# create tourism raster\ntourism_mask = rasterize(tourism_vect,\n                         template,\n                         1,\n                         background=NA)\n\n# create heatmap\ntourism_kernal = focalMat(tourism_mask, 200, \"Gauss\")\ntourism_heat = focal(tourism_mask, tourism_kernal, \n                     fun = sum, na.rm = TRUE) \ntourism_heat[is.na(tourism_heat)] = 0\ntourism_heat = tourism_heat %&gt;%\n  mask(gran_canaria_vect) %&gt;%\n  scale()\n\n# plot\nplot(tourism_heat)\nplot(gran_canaria_vect, add = TRUE)\nplot(building_vect, add = TRUE)\nmtext(text=\"Tourism Exposure\", side=3, line=2)"
  },
  {
    "objectID": "control_variables.html#calculating-building-footprint-heatmap",
    "href": "control_variables.html#calculating-building-footprint-heatmap",
    "title": "Control Variables",
    "section": "",
    "text": "# create buidling raster\nbuilding_mask = rasterize(building_vect,\n                          template,\n                          1,\n                          background=NA)\n\n# create heatmap\nbuilding_kernal = focalMat(building_mask, 199, \"Gauss\")\nbuilding_heat = focal(building_mask, building_kernal,\n                      fun = sum, na.rm = TRUE) \nbuilding_heat[is.na(building_heat)] = 0\nbuilding_heat = building_heat %&gt;%\n  mask(gran_canaria_vect) %&gt;%\n  scale()\n\nplot(building_heat)\nplot(gran_canaria_vect, add = TRUE)\nplot(building_vect, add = TRUE)\nmtext(text=\"Building Concentration\", side=3, line=2)"
  },
  {
    "objectID": "control_variables.html#calculating-elevation",
    "href": "control_variables.html#calculating-elevation",
    "title": "Control Variables",
    "section": "",
    "text": "Load in 30m resolution from STRM project. The processing steps here are just to plot and visualise it with a custom colour scale.\n\n# load elevation raster, resample, and crop\nstrm = rast(\"strm/strm.tif\") %&gt;% \n  project(crs(b2)) %&gt;%\n  resample(b2, method = \"bilinear\") %&gt;%\n  crop(bbox) %&gt;%\n  mask(gran_canaria_vect)\n\n# plot\nplot(strm)\nplot(gran_canaria_vect, add = TRUE)\nplot(building_vect, add = TRUE)\nmtext(text=\"Elevation (m)\", side=3, line=2)"
  },
  {
    "objectID": "control_variables.html#stack-and-export",
    "href": "control_variables.html#stack-and-export",
    "title": "Control Variables",
    "section": "",
    "text": "control_stack = c(coastdistance, tourism_heat, building_heat,\n                  road_heat, strm)\n\ndata_df = na.omit(as.data.frame(control_stack, xy=TRUE))\n\nnames(data_df) = c(\"X\", \"Y\", \n                   \"CoastDistance\",\"TourismExposure\",\n                   \"BuildingExposure\", \"RoadExposure\", \"Elevation\")\n\nwrite_csv(data_df, \"control_variables.csv\")"
  },
  {
    "objectID": "lsnovember.html",
    "href": "lsnovember.html",
    "title": "LandSat 8 November",
    "section": "",
    "text": "Here the LST and NDVI from LandSat 8 at 30m resolution is calculated for November 2023. This is in a similar process to Onačillová et al. (2022); Equere et al. (2021); Son et al. (2017); Karyati et al. (2022).\n\n# load packages\nlibrary(tidyverse)\nlibrary(terra)\nlibrary(RColorBrewer)\nlibrary(sf)\nlibrary(leaflet)\nlibrary(osmdata)\n\n\n\nThese rasters denote different bands of EM radiation captured by the LandSat 8 satellite over the south of Gran Canaria at 11:29am on the 13th November 2023 (U. S. Geological Surey 2023). These bands cover most of the visible light spectrum as well as the infrared spectrum. Combined in various was they can be used to calculate various measures such as the NDVI (normalised difference vegetation index) and the LST (land surface temperature).\nFirst lets plot and load the rasters\n\n# function to plot raster with a label and custome colour scale\nplot_rast = function(raster, label, colors) {\n  terra::plot(raster, col=colorRampPalette(colors)(100))\n  mtext(text=label, side=3, line=2)\n}\n\n# define the bounding box epsg:4083\nbbox = ext(c(437292.6282,445376.8775,3067829.6809,3072637.1023))\n\n# load each raster, crop to bounding box, and plot with label\nb2 = crop(rast(\"landsat_november/B2.TIF\"), bbox)\nb3 = crop(rast(\"landsat_november/B3.TIF\"), bbox)\nb4 = crop(rast(\"landsat_november/B4.TIF\"), bbox)\nb5 = crop(rast(\"landsat_november/B5.TIF\"), bbox)\nb6 = crop(rast(\"landsat_november/B6.TIF\"), bbox)\nb7 = crop(rast(\"landsat_november/B7.TIF\"), bbox)\nb10 = crop(rast(\"landsat_november/B10.TIF\"), bbox)\n\n\n\n\nUsing OSM Data to first extract a coastline of the island\n\n# query osm\ngran_canaria_query = opq(bbox = \"Gran Canaria\") %&gt;%\n  add_osm_feature(key = \"place\", value = \"island\") %&gt;%\n  osmdata_sf()\n# extract the coast data\ngran_canaria_sf = gran_canaria_query$osm_multipolygons\n\n# make spatial vector\ngran_canaria_vect = st_transform(gran_canaria_sf, crs(b2)) %&gt;%\n  vect()\n\n\n\n\n\nb2 = mask(b2, gran_canaria_vect)\nb3 = mask(b3, gran_canaria_vect)\nb4 = mask(b4, gran_canaria_vect)\nb5 = mask(b5, gran_canaria_vect)\nb6 = mask(b6, gran_canaria_vect)\nb7 = mask(b7, gran_canaria_vect)\nb10 = mask(b10, gran_canaria_vect)\n\n\n\n\nPerhaps the most important metric beside LST is NVDI. NDVI is also used in the computation of impassivity and ultimately therefore emissivity adjusted LST.\nTo calculate NDVI, the following formula is used:\n\\[\n\\text{NDVI} = \\frac{\\text{NIR} - \\text{Red}}{\\text{NIR} + \\text{Red}}\n\\]\nHere \\(NIR\\) represents the Near-Infrared band reflectance value, in Landsat 8 this is Band 5. Further \\(Red\\) represents the Red band reflectance value, in Landsat 8 this is Band 4.\n\n# calc and plot ndvi using bands 5 and 4\nndvi = (b5-b4)/(b5+b4)\n\nplot_rast(ndvi,\n          \"Normalised Difference Vegetation Index (NDVI)\",\n          c(\"brown\", \"green\"))\n\n\n\n\n\n\n\nAnother important metric is NDBI as urban artificial surfaces may trap heat causing excess heating relative to vegetated surfaces.\nTo calculate NDBI for Landsat 8, the following formula is used (Abulibdeh 2021):\n\\[\n\\text{NDVI} = \\frac{\\text{MIR} - \\text{NIR}}{\\text{MIR} + \\text{NIR}}\n\\]\nHere \\(NIR\\) again represents the Middle-Infrared band value, in Landsat 8 this is Band 5. Also \\(NIR\\) again represents the Near-Infrared band value, being Landsat 8 Band 5.\nHowever, we may not use this as for arid areas it has reduced efficacy. Instead we may rasterise OSM building data.\n\nndbi = (b6-b5)/(b6+b5)\n\nplot_rast(ndbi,\n          \"Normalised Difference Built Index (NDBI)\",\n          c(\"lightgreen\", \"black\"))\n\n\n\n\n\n\n\nComplementing these metrics is NDWI, here used to analyse the impact that surface water has upon the temperature.\nTo calculate NWBI for Landsat 8, the following formula is used:\n\\[\n\\text{NDVI} = \\frac{\\text{Green} - \\text{SWIR}}{\\text{Green} + \\text{SWIR}}\n\\]\nHere \\(Green\\) represents the Green reflectance values, in Landsat 8 this is Band 3. Also \\(SWIR\\) again represents the Short-Infrared band value, being Landsat 8 Band 7.\n\n# calc and plot\nndwi = (b3-b7)/(b3+b7)\n\nplot_rast(ndwi,\n          \"Normalised Difference Water Index (NDWI)\",\n          c(\"yellow\", \"blue\"))\n\n\n\n\n\n\n\nThere is also surface albedo \\(\\alpha\\), which is the the fraction of the reflected shortwave radiation, is calculated using the following formula (Equere et al. 2021):\n\\[\n\\alpha = \\frac{0.356·\\text{Blue} + 0.0130 · \\text{Red} + 0.373 · \\text{NIR} + 0.085 * \\text{MIR} + 0.072 · \\text{SWIR} - 0.0018}{1.016}\n\\]\nHere \\(Blue\\) represents the Blue reflectance values, in Landsat 8 this is Band 2. \\(Red\\) again represents the Red band value, being Landsat 8 Band 4. \\(NIR\\) represents the Near-Infrared values, in Landsat 8 this is Band 5. \\(MIR\\) likewise represents the Middle-Infrared values, being Landsat 8 Band 6. Finally \\(SWIR\\) represents the Near-Infrared values, in Landsat 8 this is Band 7.\n\n# calc and plot\nalbedo = (0.356*b2+0.0130*b4+0.373*b5+0.085*b6+0.072*b7-0.0018)/1.016\n\nplot_rast(albedo,\n          expression(paste(\"Surface Albedo (\", alpha,\")\")),\n          c(\"pink\", \"blue\"))\n\n\n\n\n\n\n\nCalculating LST can be straightforward in principle, using Band 10 alone of Landsat 8 data. However, this will not account for surface emissivity. Thus, for this study, an adjusted LST is calculated.\n\n\nThe first step is to convert the Digital Numbers \\(DN\\) in the Band 10 layer to Top of Atmosphere Spectral Radiance \\(L_\\lambda\\) values. This process uses input units found the images metadata/MLT file. These values are the RADIANCE_MULT_BAND_10 \\(M_L\\) and the RADIANCE_ADD_BAND_10 \\(\\text{A}_L\\).\nPutting these together into a formula is as follows:\n\\[\n\\text{L}_\\lambda = \\text{M}_L · \\text{DN} + \\text{A}_L\n\\]\n\n# define metadata values\nmult_b10 = 3.8e-04\nadd_b10 = 0.1\n\n# calc and plot\nl = (mult_b10*b10+add_b10)\n\nplot_rast(l,\n          expression(Spectral~Radiance~(L[lambda])),\n          c(\"brown\", \"yellow\"))\n\n\n\n\n\n\n\nThe second step is “Conversion of Radiance to At-Sensor Temperature” (Karyati et al. 2022). This This converts the Spectral Radiance into temperature values or Brightness Temperature \\(BT\\) in Kelvin. This process requires two constants related to Landsat 8 Band 10’s specific thermal conversion constants found again in the metadata file. These are \\(K1\\)and \\(K2\\).\nPutting this together into a formula is as follows:\n\\[\n\\text{BT} = \\frac{\\text{K2}}{ln(\\frac{\\text{K1}}{\\text{L}_\\lambda} + 1)}\n\\]\n\n# add effective wavelength of landsat b10\nk1 = 799.0284\nk2 = 1329.2405\n\n# calc and plot\nbt = (k2/log(k1/l+1))\n\nplot_rast(bt,\n          expression(Brightness~Temp~(BT)),\n          c(\"blue\", \"red\")) \n\n\n\n\n\n\n\nThe above metric alone could be used for study of heat distribution, however it does not account for the variation caused by surface level emissivity. Emissivity denotes how much infrared a surface will absorb or reflect, ranging from a mirror to a perfect black surface. The values of emissivity range from 0 to 1 respectively.\n\n\nNDVI is used to determine emissivity, through the fractional vegetation factor \\(\\text{P}_v\\). This value is specific to the region being studied.\nThe formula for calculating fractional vegetation factor is as follows:\n\\[\n\\text{P}_v = \\left( \\frac{\\text{NDVI} - \\text{NDVI}_{\\min}}{\\text{NDVI}_{\\max} - \\text{NDVI}_{\\min}} \\right)^2\n\\]\n\n# define min and max ndvi\nmin_ndvi = global(ndvi, fun=min, na.rm=TRUE) %&gt;%\n  as.numeric()\nmax_ndvi = global(ndvi, fun=max, na.rm=TRUE) %&gt;%\n  as.numeric()\n\n# calc and plot vegetation factor\npv = ((ndvi-min_ndvi)/(max_ndvi-min_ndvi))^2\n\nplot_rast(pv,\n          expression(Fractional~Vegetation~Factor~(P[v])),\n          c(\"maroon\", \"green\"))\n\n\n\n\n\n\n\nFrom this the surface emissivity can be calculated. This uses two constants relating to the relative emissivity of soil \\(\\epsilon\\text{s}\\lambda\\) and the emissivity of vegetation \\(\\epsilon\\text{v}\\lambda\\), as well as one surface roughness \\(\\text{C}\\lambda\\) metric of 0.005\nThe formula for estimating emissivity \\(\\epsilon\\lambda\\) is thus as follows:\n\\[\n\\epsilon\\lambda = \\epsilon\\text{v}\\lambda + \\epsilon\\text{s}\\lambda  · (1 - \\text{P}_v) + \\text{C}\\lambda\n\\]\n\n# soil emissivity\nes = 0.964\n\n# veg emissivity\nev = 0.984\n\n# calc and plot emissivity\ne =  ev*pv+es*(1-pv)+0.005\n\nplot_rast(e,\n          expression(Emissivity~(epsilon*lambda)),\n          c(\"yellow\", \"darkgreen\"))\n\n\n\n\n\n\n\n\nNow most of the building blocks are in place to calculate the adjusted LST. This requires a correction constant \\(\\rho\\) that incorporates the Speed of Light \\(c\\), Planck’s constant \\(h\\), and Boltzmann’s constant \\(\\sigma\\).\nThe formula for this is as follows:\n\\[\n\\rho = \\frac{c·h}{\\sigma}\n\\]\n\n# speed of light\nc = 2.997925e8 \n\n# planck's constant\nh = 6.626070e-34\n\n# boltzmann's constant\nsigma = 1.380649e-23\n\n# calc and output correction constant/rho \nrho = c*h/sigma\nrho\n\n[1] 0.01438777\n\n\n\n\n\nWith these building blocks, plus the wavelength of the emitted radiance for Landsat 8 \\(\\lambda\\), the adjusted LST \\(\\text{T}s\\) can be determined using the following formula (converting from Kelvin to Celcius:\n\\[\n\\text{T}_s = \\frac{\\text{BT}}{1 + (\\frac{\\lambda\\text{BT}}{\\rho} · ln(\\epsilon\\lambda))} - 273.15\n\\]\n\n# wavelength\nwl = 10.895e-6\n\n# calc and plot\nts = bt/(1+(wl*bt/rho)*log(e))-273.15\n\nplot_rast(ts,\n          expression(Land~Surface~Temperature~(T[s])), c(\"blue\", \"red\"))\n\n\n\n\n\n\nUsing the Leaflet Package for R (Cheng et al. 2023), we can visualise the resulting rast\n\nplet(ts,\n     col=(c(\"darkblue\",\"pink\")),\n     legend=\"bottomright\",\n     main=\"LST (Cº)\",\n     tiles=c(\"Esri.WorldImagery\"))\n\n\n\n\n\n\n\n\n\n\n\nstack = c(ndvi, ndbi, ndwi, albedo, ts)\n\ndata_df = na.omit(as.data.frame(stack, xy=TRUE))\n\ndata_df$month = \"november\"\n\nnames(data_df) = c(\"X\", \"Y\", \n                   \"NDVI\",\"NDBI\",\n                   \"NDWI\", \"Albedo\", \"TS\",\n                   \"Month\")\n\nwrite_csv(data_df, \"november.csv\")"
  },
  {
    "objectID": "lsnovember.html#loading-rasters",
    "href": "lsnovember.html#loading-rasters",
    "title": "LandSat 8 November",
    "section": "",
    "text": "These rasters denote different bands of EM radiation captured by the LandSat 8 satellite over the south of Gran Canaria at 11:29am on the 13th November 2023 (U. S. Geological Surey 2023). These bands cover most of the visible light spectrum as well as the infrared spectrum. Combined in various was they can be used to calculate various measures such as the NDVI (normalised difference vegetation index) and the LST (land surface temperature).\nFirst lets plot and load the rasters\n\n# function to plot raster with a label and custome colour scale\nplot_rast = function(raster, label, colors) {\n  terra::plot(raster, col=colorRampPalette(colors)(100))\n  mtext(text=label, side=3, line=2)\n}\n\n# define the bounding box epsg:4083\nbbox = ext(c(437292.6282,445376.8775,3067829.6809,3072637.1023))\n\n# load each raster, crop to bounding box, and plot with label\nb2 = crop(rast(\"landsat_november/B2.TIF\"), bbox)\nb3 = crop(rast(\"landsat_november/B3.TIF\"), bbox)\nb4 = crop(rast(\"landsat_november/B4.TIF\"), bbox)\nb5 = crop(rast(\"landsat_november/B5.TIF\"), bbox)\nb6 = crop(rast(\"landsat_november/B6.TIF\"), bbox)\nb7 = crop(rast(\"landsat_november/B7.TIF\"), bbox)\nb10 = crop(rast(\"landsat_november/B10.TIF\"), bbox)"
  },
  {
    "objectID": "lsnovember.html#loading-coast-shapefile",
    "href": "lsnovember.html#loading-coast-shapefile",
    "title": "LandSat 8 November",
    "section": "",
    "text": "Using OSM Data to first extract a coastline of the island\n\n# query osm\ngran_canaria_query = opq(bbox = \"Gran Canaria\") %&gt;%\n  add_osm_feature(key = \"place\", value = \"island\") %&gt;%\n  osmdata_sf()\n# extract the coast data\ngran_canaria_sf = gran_canaria_query$osm_multipolygons\n\n# make spatial vector\ngran_canaria_vect = st_transform(gran_canaria_sf, crs(b2)) %&gt;%\n  vect()"
  },
  {
    "objectID": "lsnovember.html#masking-ocean-values",
    "href": "lsnovember.html#masking-ocean-values",
    "title": "LandSat 8 November",
    "section": "",
    "text": "b2 = mask(b2, gran_canaria_vect)\nb3 = mask(b3, gran_canaria_vect)\nb4 = mask(b4, gran_canaria_vect)\nb5 = mask(b5, gran_canaria_vect)\nb6 = mask(b6, gran_canaria_vect)\nb7 = mask(b7, gran_canaria_vect)\nb10 = mask(b10, gran_canaria_vect)"
  },
  {
    "objectID": "lsnovember.html#calculating-ndvi",
    "href": "lsnovember.html#calculating-ndvi",
    "title": "LandSat 8 November",
    "section": "",
    "text": "Perhaps the most important metric beside LST is NVDI. NDVI is also used in the computation of impassivity and ultimately therefore emissivity adjusted LST.\nTo calculate NDVI, the following formula is used:\n\\[\n\\text{NDVI} = \\frac{\\text{NIR} - \\text{Red}}{\\text{NIR} + \\text{Red}}\n\\]\nHere \\(NIR\\) represents the Near-Infrared band reflectance value, in Landsat 8 this is Band 5. Further \\(Red\\) represents the Red band reflectance value, in Landsat 8 this is Band 4.\n\n# calc and plot ndvi using bands 5 and 4\nndvi = (b5-b4)/(b5+b4)\n\nplot_rast(ndvi,\n          \"Normalised Difference Vegetation Index (NDVI)\",\n          c(\"brown\", \"green\"))"
  },
  {
    "objectID": "lsnovember.html#calculating-ndbi",
    "href": "lsnovember.html#calculating-ndbi",
    "title": "LandSat 8 November",
    "section": "",
    "text": "Another important metric is NDBI as urban artificial surfaces may trap heat causing excess heating relative to vegetated surfaces.\nTo calculate NDBI for Landsat 8, the following formula is used (Abulibdeh 2021):\n\\[\n\\text{NDVI} = \\frac{\\text{MIR} - \\text{NIR}}{\\text{MIR} + \\text{NIR}}\n\\]\nHere \\(NIR\\) again represents the Middle-Infrared band value, in Landsat 8 this is Band 5. Also \\(NIR\\) again represents the Near-Infrared band value, being Landsat 8 Band 5.\nHowever, we may not use this as for arid areas it has reduced efficacy. Instead we may rasterise OSM building data.\n\nndbi = (b6-b5)/(b6+b5)\n\nplot_rast(ndbi,\n          \"Normalised Difference Built Index (NDBI)\",\n          c(\"lightgreen\", \"black\"))"
  },
  {
    "objectID": "lsnovember.html#calculating-ndwi",
    "href": "lsnovember.html#calculating-ndwi",
    "title": "LandSat 8 November",
    "section": "",
    "text": "Complementing these metrics is NDWI, here used to analyse the impact that surface water has upon the temperature.\nTo calculate NWBI for Landsat 8, the following formula is used:\n\\[\n\\text{NDVI} = \\frac{\\text{Green} - \\text{SWIR}}{\\text{Green} + \\text{SWIR}}\n\\]\nHere \\(Green\\) represents the Green reflectance values, in Landsat 8 this is Band 3. Also \\(SWIR\\) again represents the Short-Infrared band value, being Landsat 8 Band 7.\n\n# calc and plot\nndwi = (b3-b7)/(b3+b7)\n\nplot_rast(ndwi,\n          \"Normalised Difference Water Index (NDWI)\",\n          c(\"yellow\", \"blue\"))"
  },
  {
    "objectID": "lsnovember.html#calculating-surface-albedo",
    "href": "lsnovember.html#calculating-surface-albedo",
    "title": "LandSat 8 November",
    "section": "",
    "text": "There is also surface albedo \\(\\alpha\\), which is the the fraction of the reflected shortwave radiation, is calculated using the following formula (Equere et al. 2021):\n\\[\n\\alpha = \\frac{0.356·\\text{Blue} + 0.0130 · \\text{Red} + 0.373 · \\text{NIR} + 0.085 * \\text{MIR} + 0.072 · \\text{SWIR} - 0.0018}{1.016}\n\\]\nHere \\(Blue\\) represents the Blue reflectance values, in Landsat 8 this is Band 2. \\(Red\\) again represents the Red band value, being Landsat 8 Band 4. \\(NIR\\) represents the Near-Infrared values, in Landsat 8 this is Band 5. \\(MIR\\) likewise represents the Middle-Infrared values, being Landsat 8 Band 6. Finally \\(SWIR\\) represents the Near-Infrared values, in Landsat 8 this is Band 7.\n\n# calc and plot\nalbedo = (0.356*b2+0.0130*b4+0.373*b5+0.085*b6+0.072*b7-0.0018)/1.016\n\nplot_rast(albedo,\n          expression(paste(\"Surface Albedo (\", alpha,\")\")),\n          c(\"pink\", \"blue\"))"
  },
  {
    "objectID": "lsnovember.html#calculating-lst",
    "href": "lsnovember.html#calculating-lst",
    "title": "LandSat 8 November",
    "section": "",
    "text": "Calculating LST can be straightforward in principle, using Band 10 alone of Landsat 8 data. However, this will not account for surface emissivity. Thus, for this study, an adjusted LST is calculated.\n\n\nThe first step is to convert the Digital Numbers \\(DN\\) in the Band 10 layer to Top of Atmosphere Spectral Radiance \\(L_\\lambda\\) values. This process uses input units found the images metadata/MLT file. These values are the RADIANCE_MULT_BAND_10 \\(M_L\\) and the RADIANCE_ADD_BAND_10 \\(\\text{A}_L\\).\nPutting these together into a formula is as follows:\n\\[\n\\text{L}_\\lambda = \\text{M}_L · \\text{DN} + \\text{A}_L\n\\]\n\n# define metadata values\nmult_b10 = 3.8e-04\nadd_b10 = 0.1\n\n# calc and plot\nl = (mult_b10*b10+add_b10)\n\nplot_rast(l,\n          expression(Spectral~Radiance~(L[lambda])),\n          c(\"brown\", \"yellow\"))\n\n\n\n\n\n\n\nThe second step is “Conversion of Radiance to At-Sensor Temperature” (Karyati et al. 2022). This This converts the Spectral Radiance into temperature values or Brightness Temperature \\(BT\\) in Kelvin. This process requires two constants related to Landsat 8 Band 10’s specific thermal conversion constants found again in the metadata file. These are \\(K1\\)and \\(K2\\).\nPutting this together into a formula is as follows:\n\\[\n\\text{BT} = \\frac{\\text{K2}}{ln(\\frac{\\text{K1}}{\\text{L}_\\lambda} + 1)}\n\\]\n\n# add effective wavelength of landsat b10\nk1 = 799.0284\nk2 = 1329.2405\n\n# calc and plot\nbt = (k2/log(k1/l+1))\n\nplot_rast(bt,\n          expression(Brightness~Temp~(BT)),\n          c(\"blue\", \"red\")) \n\n\n\n\n\n\n\nThe above metric alone could be used for study of heat distribution, however it does not account for the variation caused by surface level emissivity. Emissivity denotes how much infrared a surface will absorb or reflect, ranging from a mirror to a perfect black surface. The values of emissivity range from 0 to 1 respectively.\n\n\nNDVI is used to determine emissivity, through the fractional vegetation factor \\(\\text{P}_v\\). This value is specific to the region being studied.\nThe formula for calculating fractional vegetation factor is as follows:\n\\[\n\\text{P}_v = \\left( \\frac{\\text{NDVI} - \\text{NDVI}_{\\min}}{\\text{NDVI}_{\\max} - \\text{NDVI}_{\\min}} \\right)^2\n\\]\n\n# define min and max ndvi\nmin_ndvi = global(ndvi, fun=min, na.rm=TRUE) %&gt;%\n  as.numeric()\nmax_ndvi = global(ndvi, fun=max, na.rm=TRUE) %&gt;%\n  as.numeric()\n\n# calc and plot vegetation factor\npv = ((ndvi-min_ndvi)/(max_ndvi-min_ndvi))^2\n\nplot_rast(pv,\n          expression(Fractional~Vegetation~Factor~(P[v])),\n          c(\"maroon\", \"green\"))\n\n\n\n\n\n\n\nFrom this the surface emissivity can be calculated. This uses two constants relating to the relative emissivity of soil \\(\\epsilon\\text{s}\\lambda\\) and the emissivity of vegetation \\(\\epsilon\\text{v}\\lambda\\), as well as one surface roughness \\(\\text{C}\\lambda\\) metric of 0.005\nThe formula for estimating emissivity \\(\\epsilon\\lambda\\) is thus as follows:\n\\[\n\\epsilon\\lambda = \\epsilon\\text{v}\\lambda + \\epsilon\\text{s}\\lambda  · (1 - \\text{P}_v) + \\text{C}\\lambda\n\\]\n\n# soil emissivity\nes = 0.964\n\n# veg emissivity\nev = 0.984\n\n# calc and plot emissivity\ne =  ev*pv+es*(1-pv)+0.005\n\nplot_rast(e,\n          expression(Emissivity~(epsilon*lambda)),\n          c(\"yellow\", \"darkgreen\"))\n\n\n\n\n\n\n\n\nNow most of the building blocks are in place to calculate the adjusted LST. This requires a correction constant \\(\\rho\\) that incorporates the Speed of Light \\(c\\), Planck’s constant \\(h\\), and Boltzmann’s constant \\(\\sigma\\).\nThe formula for this is as follows:\n\\[\n\\rho = \\frac{c·h}{\\sigma}\n\\]\n\n# speed of light\nc = 2.997925e8 \n\n# planck's constant\nh = 6.626070e-34\n\n# boltzmann's constant\nsigma = 1.380649e-23\n\n# calc and output correction constant/rho \nrho = c*h/sigma\nrho\n\n[1] 0.01438777\n\n\n\n\n\nWith these building blocks, plus the wavelength of the emitted radiance for Landsat 8 \\(\\lambda\\), the adjusted LST \\(\\text{T}s\\) can be determined using the following formula (converting from Kelvin to Celcius:\n\\[\n\\text{T}_s = \\frac{\\text{BT}}{1 + (\\frac{\\lambda\\text{BT}}{\\rho} · ln(\\epsilon\\lambda))} - 273.15\n\\]\n\n# wavelength\nwl = 10.895e-6\n\n# calc and plot\nts = bt/(1+(wl*bt/rho)*log(e))-273.15\n\nplot_rast(ts,\n          expression(Land~Surface~Temperature~(T[s])), c(\"blue\", \"red\"))\n\n\n\n\n\n\nUsing the Leaflet Package for R (Cheng et al. 2023), we can visualise the resulting rast\n\nplet(ts,\n     col=(c(\"darkblue\",\"pink\")),\n     legend=\"bottomright\",\n     main=\"LST (Cº)\",\n     tiles=c(\"Esri.WorldImagery\"))"
  },
  {
    "objectID": "lsnovember.html#stack-and-export",
    "href": "lsnovember.html#stack-and-export",
    "title": "LandSat 8 November",
    "section": "",
    "text": "stack = c(ndvi, ndbi, ndwi, albedo, ts)\n\ndata_df = na.omit(as.data.frame(stack, xy=TRUE))\n\ndata_df$month = \"november\"\n\nnames(data_df) = c(\"X\", \"Y\", \n                   \"NDVI\",\"NDBI\",\n                   \"NDWI\", \"Albedo\", \"TS\",\n                   \"Month\")\n\nwrite_csv(data_df, \"november.csv\")"
  },
  {
    "objectID": "lsseptember.html",
    "href": "lsseptember.html",
    "title": "LandSat 8 September",
    "section": "",
    "text": "Here the LST and NDVI from LandSat 8 at 30m resolution is calculated for September 2023. This is in a similar process to Onačillová et al. (2022); Equere et al. (2021); Son et al. (2017); Karyati et al. (2022).\n\n# load packages\nlibrary(tidyverse)\nlibrary(terra)\nlibrary(RColorBrewer)\nlibrary(sf)\nlibrary(leaflet)\nlibrary(osmdata)\n\n\n\nThese rasters denote different bands of EM radiation captured by the LandSat 8 satellite over the south of Gran Canaria at 11:29am on the 12th September 2023 (U. S. Geological Surey 2023). These bands cover most of the visible light spectrum as well as the infrared spectrum. Combined in various was they can be used to calculate various measures such as the NDVI (normalised difference vegetation index) and the LST (land surface temperature).\nFirst lets plot and load the rasters\n\n# function to plot raster with a label and custome colour scale\nplot_rast = function(raster, label, colors) {\n  terra::plot(raster, col=colorRampPalette(colors)(100))\n  mtext(text=label, side=3, line=2)\n}\n\n# define the bounding box epsg:4083\nbbox = ext(c(437292.6282,445376.8775,3067829.6809,3072637.1023))\n\n# load each raster, crop to bounding box, and plot with label\nb2 = crop(rast(\"landsat_september/B2.TIF\"), bbox)\nb3 = crop(rast(\"landsat_september/B3.TIF\"), bbox)\nb4 = crop(rast(\"landsat_september/B4.TIF\"), bbox)\nb5 = crop(rast(\"landsat_september/B5.TIF\"), bbox)\nb6 = crop(rast(\"landsat_september/B6.TIF\"), bbox)\nb7 = crop(rast(\"landsat_september/B7.TIF\"), bbox)\nb10 = crop(rast(\"landsat_september/B10.TIF\"), bbox)\n\n\n\n\nUsing OSM Data to first extract a coastline of the island\n\n# query osm\ngran_canaria_query = opq(bbox = \"Gran Canaria\") %&gt;%\n  add_osm_feature(key = \"place\", value = \"island\") %&gt;%\n  osmdata_sf()\n# extract the coast data\ngran_canaria_sf = gran_canaria_query$osm_multipolygons\n\n# make spatial vector\ngran_canaria_vect = st_transform(gran_canaria_sf, crs(b2)) %&gt;%\n  vect()\n\n\n\n\n\nb2 = mask(b2, gran_canaria_vect)\nb3 = mask(b3, gran_canaria_vect)\nb4 = mask(b4, gran_canaria_vect)\nb5 = mask(b5, gran_canaria_vect)\nb6 = mask(b6, gran_canaria_vect)\nb7 = mask(b7, gran_canaria_vect)\nb10 = mask(b10, gran_canaria_vect)\n\n\n\n\nPerhaps the most important metric beside LST is NVDI. NDVI is also used in the computation of impassivity and ultimately therefore emissivity adjusted LST.\nTo calculate NDVI, the following formula is used:\n\\[\n\\text{NDVI} = \\frac{\\text{NIR} - \\text{Red}}{\\text{NIR} + \\text{Red}}\n\\]\nHere \\(NIR\\) represents the Near-Infrared band reflectance value, in Landsat 8 this is Band 5. Further \\(Red\\) represents the Red band reflectance value, in Landsat 8 this is Band 4.\n\n# calc and plot ndvi using bands 5 and 4\nndvi = (b5-b4)/(b5+b4)\n\nplot_rast(ndvi,\n          \"Normalised Difference Vegetation Index (NDVI)\",\n          c(\"brown\", \"green\"))\n\n\n\n\n\n\n\nAnother important metric is NDBI as urban artificial surfaces may trap heat causing excess heating relative to vegetated surfaces.\nTo calculate NDBI for Landsat 8, the following formula is used (Abulibdeh 2021):\n\\[\n\\text{NDVI} = \\frac{\\text{MIR} - \\text{NIR}}{\\text{MIR} + \\text{NIR}}\n\\]\nHere \\(NIR\\) again represents the Middle-Infrared band value, in Landsat 8 this is Band 5. Also \\(NIR\\) again represents the Near-Infrared band value, being Landsat 8 Band 5.\nHowever, we may not use this as for arid areas it has reduced efficacy. Instead we may rasterise OSM building data.\n\nndbi = (b6-b5)/(b6+b5)\n\nplot_rast(ndbi,\n          \"Normalised Difference Built Index (NDBI)\",\n          c(\"lightgreen\", \"black\"))\n\n\n\n\n\n\n\nComplementing these metrics is NDWI, here used to analyse the impact that surface water has upon the temperature.\nTo calculate NWBI for Landsat 8, the following formula is used:\n\\[\n\\text{NDVI} = \\frac{\\text{Green} - \\text{SWIR}}{\\text{Green} + \\text{SWIR}}\n\\]\nHere \\(Green\\) represents the Green reflectance values, in Landsat 8 this is Band 3. Also \\(SWIR\\) again represents the Short-Infrared band value, being Landsat 8 Band 7.\n\n# calc and plot\nndwi = (b3-b7)/(b3+b7)\n\nplot_rast(ndwi,\n          \"Normalised Difference Water Index (NDWI)\",\n          c(\"yellow\", \"blue\"))\n\n\n\n\n\n\n\nThere is also surface albedo \\(\\alpha\\), which is the the fraction of the reflected shortwave radiation, is calculated using the following formula (Equere et al. 2021):\n\\[\n\\alpha = \\frac{0.356·\\text{Blue} + 0.0130 · \\text{Red} + 0.373 · \\text{NIR} + 0.085 * \\text{MIR} + 0.072 · \\text{SWIR} - 0.0018}{1.016}\n\\]\nHere \\(Blue\\) represents the Blue reflectance values, in Landsat 8 this is Band 2. \\(Red\\) again represents the Red band value, being Landsat 8 Band 4. \\(NIR\\) represents the Near-Infrared values, in Landsat 8 this is Band 5. \\(MIR\\) likewise represents the Middle-Infrared values, being Landsat 8 Band 6. Finally \\(SWIR\\) represents the Near-Infrared values, in Landsat 8 this is Band 7.\n\n# calc and plot\nalbedo = (0.356*b2+0.0130*b4+0.373*b5+0.085*b6+0.072*b7-0.0018)/1.016\n\nplot_rast(albedo,\n          expression(paste(\"Surface Albedo (\", alpha,\")\")),\n          c(\"pink\", \"blue\"))\n\n\n\n\n\n\n\nCalculating LST can be straightforward in principle, using Band 10 alone of Landsat 8 data. However, this will not account for surface emissivity. Thus, for this study, an adjusted LST is calculated.\n\n\nThe first step is to convert the Digital Numbers \\(DN\\) in the Band 10 layer to Top of Atmosphere Spectral Radiance \\(L_\\lambda\\) values. This process uses input units found the images metadata/MLT file. These values are the RADIANCE_MULT_BAND_10 \\(M_L\\) and the RADIANCE_ADD_BAND_10 \\(\\text{A}_L\\).\nPutting these together into a formula is as follows:\n\\[\n\\text{L}_\\lambda = \\text{M}_L · \\text{DN} + \\text{A}_L\n\\]\n\n# define metadata values\nmult_b10 = 3.8e-04\nadd_b10 = 0.1\n\n# calc and plot\nl = (mult_b10*b10+add_b10)\n\nplot_rast(l,\n          expression(Spectral~Radiance~(L[lambda])),\n          c(\"brown\", \"yellow\"))\n\n\n\n\n\n\n\nThe second step is “Conversion of Radiance to At-Sensor Temperature” (Karyati et al. 2022). This This converts the Spectral Radiance into temperature values or Brightness Temperature \\(BT\\) in Kelvin. This process requires two constants related to Landsat 8 Band 10’s specific thermal conversion constants found again in the metadata file. These are \\(K1\\)and \\(K2\\).\nPutting this together into a formula is as follows:\n\\[\n\\text{BT} = \\frac{\\text{K2}}{ln(\\frac{\\text{K1}}{\\text{L}_\\lambda} + 1)}\n\\]\n\n# add effective wavelength of landsat b10\nk1 = 799.0284\nk2 = 1329.2405\n\n# calc and plot\nbt = (k2/log(k1/l+1))\n\nplot_rast(bt,\n          expression(Brightness~Temp~(BT)),\n          c(\"blue\", \"red\")) \n\n\n\n\n\n\n\nThe above metric alone could be used for study of heat distribution, however it does not account for the variation caused by surface level emissivity. Emissivity denotes how much infrared a surface will absorb or reflect, ranging from a mirror to a perfect black surface. The values of emissivity range from 0 to 1 respectively.\n\n\nNDVI is used to determine emissivity, through the fractional vegetation factor \\(\\text{P}_v\\). This value is specific to the region being studied.\nThe formula for calculating fractional vegetation factor is as follows:\n\\[\n\\text{P}_v = \\left( \\frac{\\text{NDVI} - \\text{NDVI}_{\\min}}{\\text{NDVI}_{\\max} - \\text{NDVI}_{\\min}} \\right)^2\n\\]\n\n# define min and max ndvi\nmin_ndvi = global(ndvi, fun=min, na.rm=TRUE) %&gt;%\n  as.numeric()\nmax_ndvi = global(ndvi, fun=max, na.rm=TRUE) %&gt;%\n  as.numeric()\n\n# calc and plot vegetation factor\npv = ((ndvi-min_ndvi)/(max_ndvi-min_ndvi))^2\n\nplot_rast(pv,\n          expression(Fractional~Vegetation~Factor~(P[v])),\n          c(\"maroon\", \"green\"))\n\n\n\n\n\n\n\nFrom this the surface emissivity can be calculated. This uses two constants relating to the relative emissivity of soil \\(\\epsilon\\text{s}\\lambda\\) and the emissivity of vegetation \\(\\epsilon\\text{v}\\lambda\\), as well as one surface roughness \\(\\text{C}\\lambda\\) metric of 0.005\nThe formula for estimating emissivity \\(\\epsilon\\lambda\\) is thus as follows:\n\\[\n\\epsilon\\lambda = \\epsilon\\text{v}\\lambda + \\epsilon\\text{s}\\lambda  · (1 - \\text{P}_v) + \\text{C}\\lambda\n\\]\n\n# soil emissivity\nes = 0.964\n\n# veg emissivity\nev = 0.984\n\n# calc and plot emissivity\ne =  ev*pv+es*(1-pv)+0.005\n\nplot_rast(e,\n          expression(Emissivity~(epsilon*lambda)),\n          c(\"yellow\", \"darkgreen\"))\n\n\n\n\n\n\n\n\nNow most of the building blocks are in place to calculate the adjusted LST. This requires a correction constant \\(\\rho\\) that incorporates the Speed of Light \\(c\\), Planck’s constant \\(h\\), and Boltzmann’s constant \\(\\sigma\\).\nThe formula for this is as follows:\n\\[\n\\rho = \\frac{c·h}{\\sigma}\n\\]\n\n# speed of light\nc = 2.997925e8 \n\n# planck's constant\nh = 6.626070e-34\n\n# boltzmann's constant\nsigma = 1.380649e-23\n\n# calc and output correction constant/rho \nrho = c*h/sigma\nrho\n\n[1] 0.01438777\n\n\n\n\n\nWith these building blocks, plus the wavelength of the emitted radiance for Landsat 8 \\(\\lambda\\), the adjusted LST \\(\\text{T}s\\) can be determined using the following formula (converting from Kelvin to Celcius:\n\\[\n\\text{T}_s = \\frac{\\text{BT}}{1 + (\\frac{\\lambda\\text{BT}}{\\rho} · ln(\\epsilon\\lambda))} - 273.15\n\\]\n\n# wavelength\nwl = 10.895e-6\n\n# calc and plot\nts = bt/(1+(wl*bt/rho)*log(e))-273.15\n\nplot_rast(ts,\n          expression(Land~Surface~Temperature~(T[s])), c(\"blue\", \"red\"))\n\n\n\n\n\n\nUsing the Leaflet Package for R (Cheng et al. 2023), we can visualise the resulting rast\n\nplet(ts,\n     col=(c(\"darkblue\",\"pink\")),\n     legend=\"bottomright\",\n     main=\"LST (Cº)\",\n     tiles=c(\"Esri.WorldImagery\"))\n\n\n\n\n\n\n\n\n\n\n\nstack = c(ndvi, ndbi, ndwi, albedo, ts)\n\ndata_df = na.omit(as.data.frame(stack, xy=TRUE))\n\ndata_df$month = \"september\"\n\nnames(data_df) = c(\"X\", \"Y\", \n                   \"NDVI\",\"NDBI\",\n                   \"NDWI\", \"Albedo\", \"TS\",\n                   \"Month\")\n\nwrite_csv(data_df, \"september.csv\")"
  },
  {
    "objectID": "lsseptember.html#loading-rasters",
    "href": "lsseptember.html#loading-rasters",
    "title": "LandSat 8 September",
    "section": "",
    "text": "These rasters denote different bands of EM radiation captured by the LandSat 8 satellite over the south of Gran Canaria at 11:29am on the 12th September 2023 (U. S. Geological Surey 2023). These bands cover most of the visible light spectrum as well as the infrared spectrum. Combined in various was they can be used to calculate various measures such as the NDVI (normalised difference vegetation index) and the LST (land surface temperature).\nFirst lets plot and load the rasters\n\n# function to plot raster with a label and custome colour scale\nplot_rast = function(raster, label, colors) {\n  terra::plot(raster, col=colorRampPalette(colors)(100))\n  mtext(text=label, side=3, line=2)\n}\n\n# define the bounding box epsg:4083\nbbox = ext(c(437292.6282,445376.8775,3067829.6809,3072637.1023))\n\n# load each raster, crop to bounding box, and plot with label\nb2 = crop(rast(\"landsat_september/B2.TIF\"), bbox)\nb3 = crop(rast(\"landsat_september/B3.TIF\"), bbox)\nb4 = crop(rast(\"landsat_september/B4.TIF\"), bbox)\nb5 = crop(rast(\"landsat_september/B5.TIF\"), bbox)\nb6 = crop(rast(\"landsat_september/B6.TIF\"), bbox)\nb7 = crop(rast(\"landsat_september/B7.TIF\"), bbox)\nb10 = crop(rast(\"landsat_september/B10.TIF\"), bbox)"
  },
  {
    "objectID": "lsseptember.html#loading-coast-shapefile",
    "href": "lsseptember.html#loading-coast-shapefile",
    "title": "LandSat 8 September",
    "section": "",
    "text": "Using OSM Data to first extract a coastline of the island\n\n# query osm\ngran_canaria_query = opq(bbox = \"Gran Canaria\") %&gt;%\n  add_osm_feature(key = \"place\", value = \"island\") %&gt;%\n  osmdata_sf()\n# extract the coast data\ngran_canaria_sf = gran_canaria_query$osm_multipolygons\n\n# make spatial vector\ngran_canaria_vect = st_transform(gran_canaria_sf, crs(b2)) %&gt;%\n  vect()"
  },
  {
    "objectID": "lsseptember.html#masking-ocean-values",
    "href": "lsseptember.html#masking-ocean-values",
    "title": "LandSat 8 September",
    "section": "",
    "text": "b2 = mask(b2, gran_canaria_vect)\nb3 = mask(b3, gran_canaria_vect)\nb4 = mask(b4, gran_canaria_vect)\nb5 = mask(b5, gran_canaria_vect)\nb6 = mask(b6, gran_canaria_vect)\nb7 = mask(b7, gran_canaria_vect)\nb10 = mask(b10, gran_canaria_vect)"
  },
  {
    "objectID": "lsseptember.html#calculating-ndvi",
    "href": "lsseptember.html#calculating-ndvi",
    "title": "LandSat 8 September",
    "section": "",
    "text": "Perhaps the most important metric beside LST is NVDI. NDVI is also used in the computation of impassivity and ultimately therefore emissivity adjusted LST.\nTo calculate NDVI, the following formula is used:\n\\[\n\\text{NDVI} = \\frac{\\text{NIR} - \\text{Red}}{\\text{NIR} + \\text{Red}}\n\\]\nHere \\(NIR\\) represents the Near-Infrared band reflectance value, in Landsat 8 this is Band 5. Further \\(Red\\) represents the Red band reflectance value, in Landsat 8 this is Band 4.\n\n# calc and plot ndvi using bands 5 and 4\nndvi = (b5-b4)/(b5+b4)\n\nplot_rast(ndvi,\n          \"Normalised Difference Vegetation Index (NDVI)\",\n          c(\"brown\", \"green\"))"
  },
  {
    "objectID": "lsseptember.html#calculating-ndbi",
    "href": "lsseptember.html#calculating-ndbi",
    "title": "LandSat 8 September",
    "section": "",
    "text": "Another important metric is NDBI as urban artificial surfaces may trap heat causing excess heating relative to vegetated surfaces.\nTo calculate NDBI for Landsat 8, the following formula is used (Abulibdeh 2021):\n\\[\n\\text{NDVI} = \\frac{\\text{MIR} - \\text{NIR}}{\\text{MIR} + \\text{NIR}}\n\\]\nHere \\(NIR\\) again represents the Middle-Infrared band value, in Landsat 8 this is Band 5. Also \\(NIR\\) again represents the Near-Infrared band value, being Landsat 8 Band 5.\nHowever, we may not use this as for arid areas it has reduced efficacy. Instead we may rasterise OSM building data.\n\nndbi = (b6-b5)/(b6+b5)\n\nplot_rast(ndbi,\n          \"Normalised Difference Built Index (NDBI)\",\n          c(\"lightgreen\", \"black\"))"
  },
  {
    "objectID": "lsseptember.html#calculating-ndwi",
    "href": "lsseptember.html#calculating-ndwi",
    "title": "LandSat 8 September",
    "section": "",
    "text": "Complementing these metrics is NDWI, here used to analyse the impact that surface water has upon the temperature.\nTo calculate NWBI for Landsat 8, the following formula is used:\n\\[\n\\text{NDVI} = \\frac{\\text{Green} - \\text{SWIR}}{\\text{Green} + \\text{SWIR}}\n\\]\nHere \\(Green\\) represents the Green reflectance values, in Landsat 8 this is Band 3. Also \\(SWIR\\) again represents the Short-Infrared band value, being Landsat 8 Band 7.\n\n# calc and plot\nndwi = (b3-b7)/(b3+b7)\n\nplot_rast(ndwi,\n          \"Normalised Difference Water Index (NDWI)\",\n          c(\"yellow\", \"blue\"))"
  },
  {
    "objectID": "lsseptember.html#calculating-surface-albedo",
    "href": "lsseptember.html#calculating-surface-albedo",
    "title": "LandSat 8 September",
    "section": "",
    "text": "There is also surface albedo \\(\\alpha\\), which is the the fraction of the reflected shortwave radiation, is calculated using the following formula (Equere et al. 2021):\n\\[\n\\alpha = \\frac{0.356·\\text{Blue} + 0.0130 · \\text{Red} + 0.373 · \\text{NIR} + 0.085 * \\text{MIR} + 0.072 · \\text{SWIR} - 0.0018}{1.016}\n\\]\nHere \\(Blue\\) represents the Blue reflectance values, in Landsat 8 this is Band 2. \\(Red\\) again represents the Red band value, being Landsat 8 Band 4. \\(NIR\\) represents the Near-Infrared values, in Landsat 8 this is Band 5. \\(MIR\\) likewise represents the Middle-Infrared values, being Landsat 8 Band 6. Finally \\(SWIR\\) represents the Near-Infrared values, in Landsat 8 this is Band 7.\n\n# calc and plot\nalbedo = (0.356*b2+0.0130*b4+0.373*b5+0.085*b6+0.072*b7-0.0018)/1.016\n\nplot_rast(albedo,\n          expression(paste(\"Surface Albedo (\", alpha,\")\")),\n          c(\"pink\", \"blue\"))"
  },
  {
    "objectID": "lsseptember.html#calculating-lst",
    "href": "lsseptember.html#calculating-lst",
    "title": "LandSat 8 September",
    "section": "",
    "text": "Calculating LST can be straightforward in principle, using Band 10 alone of Landsat 8 data. However, this will not account for surface emissivity. Thus, for this study, an adjusted LST is calculated.\n\n\nThe first step is to convert the Digital Numbers \\(DN\\) in the Band 10 layer to Top of Atmosphere Spectral Radiance \\(L_\\lambda\\) values. This process uses input units found the images metadata/MLT file. These values are the RADIANCE_MULT_BAND_10 \\(M_L\\) and the RADIANCE_ADD_BAND_10 \\(\\text{A}_L\\).\nPutting these together into a formula is as follows:\n\\[\n\\text{L}_\\lambda = \\text{M}_L · \\text{DN} + \\text{A}_L\n\\]\n\n# define metadata values\nmult_b10 = 3.8e-04\nadd_b10 = 0.1\n\n# calc and plot\nl = (mult_b10*b10+add_b10)\n\nplot_rast(l,\n          expression(Spectral~Radiance~(L[lambda])),\n          c(\"brown\", \"yellow\"))\n\n\n\n\n\n\n\nThe second step is “Conversion of Radiance to At-Sensor Temperature” (Karyati et al. 2022). This This converts the Spectral Radiance into temperature values or Brightness Temperature \\(BT\\) in Kelvin. This process requires two constants related to Landsat 8 Band 10’s specific thermal conversion constants found again in the metadata file. These are \\(K1\\)and \\(K2\\).\nPutting this together into a formula is as follows:\n\\[\n\\text{BT} = \\frac{\\text{K2}}{ln(\\frac{\\text{K1}}{\\text{L}_\\lambda} + 1)}\n\\]\n\n# add effective wavelength of landsat b10\nk1 = 799.0284\nk2 = 1329.2405\n\n# calc and plot\nbt = (k2/log(k1/l+1))\n\nplot_rast(bt,\n          expression(Brightness~Temp~(BT)),\n          c(\"blue\", \"red\")) \n\n\n\n\n\n\n\nThe above metric alone could be used for study of heat distribution, however it does not account for the variation caused by surface level emissivity. Emissivity denotes how much infrared a surface will absorb or reflect, ranging from a mirror to a perfect black surface. The values of emissivity range from 0 to 1 respectively.\n\n\nNDVI is used to determine emissivity, through the fractional vegetation factor \\(\\text{P}_v\\). This value is specific to the region being studied.\nThe formula for calculating fractional vegetation factor is as follows:\n\\[\n\\text{P}_v = \\left( \\frac{\\text{NDVI} - \\text{NDVI}_{\\min}}{\\text{NDVI}_{\\max} - \\text{NDVI}_{\\min}} \\right)^2\n\\]\n\n# define min and max ndvi\nmin_ndvi = global(ndvi, fun=min, na.rm=TRUE) %&gt;%\n  as.numeric()\nmax_ndvi = global(ndvi, fun=max, na.rm=TRUE) %&gt;%\n  as.numeric()\n\n# calc and plot vegetation factor\npv = ((ndvi-min_ndvi)/(max_ndvi-min_ndvi))^2\n\nplot_rast(pv,\n          expression(Fractional~Vegetation~Factor~(P[v])),\n          c(\"maroon\", \"green\"))\n\n\n\n\n\n\n\nFrom this the surface emissivity can be calculated. This uses two constants relating to the relative emissivity of soil \\(\\epsilon\\text{s}\\lambda\\) and the emissivity of vegetation \\(\\epsilon\\text{v}\\lambda\\), as well as one surface roughness \\(\\text{C}\\lambda\\) metric of 0.005\nThe formula for estimating emissivity \\(\\epsilon\\lambda\\) is thus as follows:\n\\[\n\\epsilon\\lambda = \\epsilon\\text{v}\\lambda + \\epsilon\\text{s}\\lambda  · (1 - \\text{P}_v) + \\text{C}\\lambda\n\\]\n\n# soil emissivity\nes = 0.964\n\n# veg emissivity\nev = 0.984\n\n# calc and plot emissivity\ne =  ev*pv+es*(1-pv)+0.005\n\nplot_rast(e,\n          expression(Emissivity~(epsilon*lambda)),\n          c(\"yellow\", \"darkgreen\"))\n\n\n\n\n\n\n\n\nNow most of the building blocks are in place to calculate the adjusted LST. This requires a correction constant \\(\\rho\\) that incorporates the Speed of Light \\(c\\), Planck’s constant \\(h\\), and Boltzmann’s constant \\(\\sigma\\).\nThe formula for this is as follows:\n\\[\n\\rho = \\frac{c·h}{\\sigma}\n\\]\n\n# speed of light\nc = 2.997925e8 \n\n# planck's constant\nh = 6.626070e-34\n\n# boltzmann's constant\nsigma = 1.380649e-23\n\n# calc and output correction constant/rho \nrho = c*h/sigma\nrho\n\n[1] 0.01438777\n\n\n\n\n\nWith these building blocks, plus the wavelength of the emitted radiance for Landsat 8 \\(\\lambda\\), the adjusted LST \\(\\text{T}s\\) can be determined using the following formula (converting from Kelvin to Celcius:\n\\[\n\\text{T}_s = \\frac{\\text{BT}}{1 + (\\frac{\\lambda\\text{BT}}{\\rho} · ln(\\epsilon\\lambda))} - 273.15\n\\]\n\n# wavelength\nwl = 10.895e-6\n\n# calc and plot\nts = bt/(1+(wl*bt/rho)*log(e))-273.15\n\nplot_rast(ts,\n          expression(Land~Surface~Temperature~(T[s])), c(\"blue\", \"red\"))\n\n\n\n\n\n\nUsing the Leaflet Package for R (Cheng et al. 2023), we can visualise the resulting rast\n\nplet(ts,\n     col=(c(\"darkblue\",\"pink\")),\n     legend=\"bottomright\",\n     main=\"LST (Cº)\",\n     tiles=c(\"Esri.WorldImagery\"))"
  },
  {
    "objectID": "lsseptember.html#stack-and-export",
    "href": "lsseptember.html#stack-and-export",
    "title": "LandSat 8 September",
    "section": "",
    "text": "stack = c(ndvi, ndbi, ndwi, albedo, ts)\n\ndata_df = na.omit(as.data.frame(stack, xy=TRUE))\n\ndata_df$month = \"september\"\n\nnames(data_df) = c(\"X\", \"Y\", \n                   \"NDVI\",\"NDBI\",\n                   \"NDWI\", \"Albedo\", \"TS\",\n                   \"Month\")\n\nwrite_csv(data_df, \"september.csv\")"
  },
  {
    "objectID": "lsmay.html",
    "href": "lsmay.html",
    "title": "LandSat 8 May",
    "section": "",
    "text": "Here the LST and NDVI from LandSat 8 at 30m resolution is calculated for May 2023. This is in a similar process to Onačillová et al. (2022); Equere et al. (2021); Son et al. (2017); Karyati et al. (2022).\n\n# load packages\nlibrary(tidyverse)\nlibrary(terra)\nlibrary(RColorBrewer)\nlibrary(sf)\nlibrary(leaflet)\nlibrary(osmdata)\n\n\n\nThese rasters denote different bands of EM radiation captured by the LandSat 8 satellite over the south of Gran Canaria at 11:29am on the 18th May 2023 (U. S. Geological Surey 2023). These bands cover most of the visible light spectrum as well as the infrared spectrum. Combined in various was they can be used to calculate various measures such as the NDVI (normalised difference vegetation index) and the LST (land surface temperature).\nFirst lets plot and load the rasters\n\n# function to plot raster with a label and custome colour scale\nplot_rast = function(raster, label, colors) {\n  terra::plot(raster, col=colorRampPalette(colors)(100))\n  mtext(text=label, side=3, line=2)\n}\n\n# define the bounding box epsg:4083\nbbox = ext(c(437292.6282,445376.8775,3067829.6809,3072637.1023))\n\n# load each raster, crop to bounding box, and plot with label\nb2 = crop(rast(\"landsat_may/B2.TIF\"), bbox)\nb3 = crop(rast(\"landsat_may/B3.TIF\"), bbox)\nb4 = crop(rast(\"landsat_may/B4.TIF\"), bbox)\nb5 = crop(rast(\"landsat_may/B5.TIF\"), bbox)\nb6 = crop(rast(\"landsat_may/B6.TIF\"), bbox)\nb7 = crop(rast(\"landsat_may/B7.TIF\"), bbox)\nb10 = crop(rast(\"landsat_may/B10.TIF\"), bbox)\n\n\n\n\nUsing OSM Data to first extract a coastline of the island\n\n# query osm\ngran_canaria_query = opq(bbox = \"Gran Canaria\") %&gt;%\n  add_osm_feature(key = \"place\", value = \"island\") %&gt;%\n  osmdata_sf()\n# extract the coast data\ngran_canaria_sf = gran_canaria_query$osm_multipolygons\n\n# make spatial vector\ngran_canaria_vect = st_transform(gran_canaria_sf, crs(b2)) %&gt;%\n  vect()\n\n\n\n\n\nb2 = mask(b2, gran_canaria_vect)\nb3 = mask(b3, gran_canaria_vect)\nb4 = mask(b4, gran_canaria_vect)\nb5 = mask(b5, gran_canaria_vect)\nb6 = mask(b6, gran_canaria_vect)\nb7 = mask(b7, gran_canaria_vect)\nb10 = mask(b10, gran_canaria_vect)\n\n\n\n\nPerhaps the most important metric beside LST is NVDI. NDVI is also used in the computation of impassivity and ultimately therefore emissivity adjusted LST.\nTo calculate NDVI, the following formula is used:\n\\[\n\\text{NDVI} = \\frac{\\text{NIR} - \\text{Red}}{\\text{NIR} + \\text{Red}}\n\\]\nHere \\(NIR\\) represents the Near-Infrared band reflectance value, in Landsat 8 this is Band 5. Further \\(Red\\) represents the Red band reflectance value, in Landsat 8 this is Band 4.\n\n# calc and plot ndvi using bands 5 and 4\nndvi = (b5-b4)/(b5+b4)\n\nplot_rast(ndvi,\n          \"Normalised Difference Vegetation Index (NDVI)\",\n          c(\"brown\", \"green\"))\n\n\n\n\n\n\n\nAnother important metric is NDBI as urban artificial surfaces may trap heat causing excess heating relative to vegetated surfaces.\nTo calculate NDBI for Landsat 8, the following formula is used (Abulibdeh 2021):\n\\[\n\\text{NDVI} = \\frac{\\text{MIR} - \\text{NIR}}{\\text{MIR} + \\text{NIR}}\n\\]\nHere \\(NIR\\) again represents the Middle-Infrared band value, in Landsat 8 this is Band 5. Also \\(NIR\\) again represents the Near-Infrared band value, being Landsat 8 Band 5.\nHowever, we may not use this as for arid areas it has reduced efficacy. Instead we may rasterise OSM building data.\n\nndbi = (b6-b5)/(b6+b5)\n\nplot_rast(ndbi,\n          \"Normalised Difference Built Index (NDBI)\",\n          c(\"lightgreen\", \"black\"))\n\n\n\n\n\n\n\nComplementing these metrics is NDWI, here used to analyse the impact that surface water has upon the temperature.\nTo calculate NWBI for Landsat 8, the following formula is used:\n\\[\n\\text{NDVI} = \\frac{\\text{Green} - \\text{SWIR}}{\\text{Green} + \\text{SWIR}}\n\\]\nHere \\(Green\\) represents the Green reflectance values, in Landsat 8 this is Band 3. Also \\(SWIR\\) again represents the Short-Infrared band value, being Landsat 8 Band 7.\n\n# calc and plot\nndwi = (b3-b7)/(b3+b7)\n\nplot_rast(ndwi,\n          \"Normalised Difference Water Index (NDWI)\",\n          c(\"yellow\", \"blue\"))\n\n\n\n\n\n\n\nThere is also surface albedo \\(\\alpha\\), which is the the fraction of the reflected shortwave radiation, is calculated using the following formula (Equere et al. 2021):\n\\[\n\\alpha = \\frac{0.356·\\text{Blue} + 0.0130 · \\text{Red} + 0.373 · \\text{NIR} + 0.085 * \\text{MIR} + 0.072 · \\text{SWIR} - 0.0018}{1.016}\n\\]\nHere \\(Blue\\) represents the Blue reflectance values, in Landsat 8 this is Band 2. \\(Red\\) again represents the Red band value, being Landsat 8 Band 4. \\(NIR\\) represents the Near-Infrared values, in Landsat 8 this is Band 5. \\(MIR\\) likewise represents the Middle-Infrared values, being Landsat 8 Band 6. Finally \\(SWIR\\) represents the Near-Infrared values, in Landsat 8 this is Band 7.\n\n# calc and plot\nalbedo = (0.356*b2+0.0130*b4+0.373*b5+0.085*b6+0.072*b7-0.0018)/1.016\n\nplot_rast(albedo,\n          expression(paste(\"Surface Albedo (\", alpha,\")\")),\n          c(\"pink\", \"blue\"))\n\n\n\n\n\n\n\nCalculating LST can be straightforward in principle, using Band 10 alone of Landsat 8 data. However, this will not account for surface emissivity. Thus, for this study, an adjusted LST is calculated.\n\n\nThe first step is to convert the Digital Numbers \\(DN\\) in the Band 10 layer to Top of Atmosphere Spectral Radiance \\(L_\\lambda\\) values. This process uses input units found the images metadata/MLT file. These values are the RADIANCE_MULT_BAND_10 \\(M_L\\) and the RADIANCE_ADD_BAND_10 \\(\\text{A}_L\\).\nPutting these together into a formula is as follows:\n\\[\n\\text{L}_\\lambda = \\text{M}_L · \\text{DN} + \\text{A}_L\n\\]\n\n# define metadata values\nmult_b10 = 3.8e-04\nadd_b10 = 0.1\n\n# calc and plot\nl = (mult_b10*b10+add_b10)\n\nplot_rast(l,\n          expression(Spectral~Radiance~(L[lambda])),\n          c(\"brown\", \"yellow\"))\n\n\n\n\n\n\n\nThe second step is “Conversion of Radiance to At-Sensor Temperature” (Karyati et al. 2022). This This converts the Spectral Radiance into temperature values or Brightness Temperature \\(BT\\) in Kelvin. This process requires two constants related to Landsat 8 Band 10’s specific thermal conversion constants found again in the metadata file. These are \\(K1\\)and \\(K2\\).\nPutting this together into a formula is as follows:\n\\[\n\\text{BT} = \\frac{\\text{K2}}{ln(\\frac{\\text{K1}}{\\text{L}_\\lambda} + 1)}\n\\]\n\n# add effective wavelength of landsat b10\nk1 = 799.0284\nk2 = 1329.2405\n\n# calc and plot\nbt = (k2/log(k1/l+1))\n\nplot_rast(bt,\n          expression(Brightness~Temp~(BT)),\n          c(\"blue\", \"red\")) \n\n\n\n\n\n\n\nThe above metric alone could be used for study of heat distribution, however it does not account for the variation caused by surface level emissivity. Emissivity denotes how much infrared a surface will absorb or reflect, ranging from a mirror to a perfect black surface. The values of emissivity range from 0 to 1 respectively.\n\n\nNDVI is used to determine emissivity, through the fractional vegetation factor \\(\\text{P}_v\\). This value is specific to the region being studied.\nThe formula for calculating fractional vegetation factor is as follows:\n\\[\n\\text{P}_v = \\left( \\frac{\\text{NDVI} - \\text{NDVI}_{\\min}}{\\text{NDVI}_{\\max} - \\text{NDVI}_{\\min}} \\right)^2\n\\]\n\n# define min and max ndvi\nmin_ndvi = global(ndvi, fun=min, na.rm=TRUE) %&gt;%\n  as.numeric()\nmax_ndvi = global(ndvi, fun=max, na.rm=TRUE) %&gt;%\n  as.numeric()\n\n# calc and plot vegetation factor\npv = ((ndvi-min_ndvi)/(max_ndvi-min_ndvi))^2\n\nplot_rast(pv,\n          expression(Fractional~Vegetation~Factor~(P[v])),\n          c(\"maroon\", \"green\"))\n\n\n\n\n\n\n\nFrom this the surface emissivity can be calculated. This uses two constants relating to the relative emissivity of soil \\(\\epsilon\\text{s}\\lambda\\) and the emissivity of vegetation \\(\\epsilon\\text{v}\\lambda\\), as well as one surface roughness \\(\\text{C}\\lambda\\) metric of 0.005\nThe formula for estimating emissivity \\(\\epsilon\\lambda\\) is thus as follows:\n\\[\n\\epsilon\\lambda = \\epsilon\\text{v}\\lambda + \\epsilon\\text{s}\\lambda  · (1 - \\text{P}_v) + \\text{C}\\lambda\n\\]\n\n# soil emissivity\nes = 0.964\n\n# veg emissivity\nev = 0.984\n\n# calc and plot emissivity\ne =  ev*pv+es*(1-pv)+0.005\n\nplot_rast(e,\n          expression(Emissivity~(epsilon*lambda)),\n          c(\"yellow\", \"darkgreen\"))\n\n\n\n\n\n\n\n\nNow most of the building blocks are in place to calculate the adjusted LST. This requires a correction constant \\(\\rho\\) that incorporates the Speed of Light \\(c\\), Planck’s constant \\(h\\), and Boltzmann’s constant \\(\\sigma\\).\nThe formula for this is as follows:\n\\[\n\\rho = \\frac{c·h}{\\sigma}\n\\]\n\n# speed of light\nc = 2.997925e8 \n\n# planck's constant\nh = 6.626070e-34\n\n# boltzmann's constant\nsigma = 1.380649e-23\n\n# calc and output correction constant/rho \nrho = c*h/sigma\nrho\n\n[1] 0.01438777\n\n\n\n\n\nWith these building blocks, plus the wavelength of the emitted radiance for Landsat 8 \\(\\lambda\\), the adjusted LST \\(\\text{T}s\\) can be determined using the following formula (converting from Kelvin to Celcius:\n\\[\n\\text{T}_s = \\frac{\\text{BT}}{1 + (\\frac{\\lambda\\text{BT}}{\\rho} · ln(\\epsilon\\lambda))} - 273.15\n\\]\n\n# wavelength\nwl = 10.895e-6\n\n# calc and plot\nts = bt/(1+(wl*bt/rho)*log(e))-273.15\n\nplot_rast(ts,\n          expression(Land~Surface~Temperature~(T[s])), c(\"blue\", \"red\"))\n\n\n\n\n\n\nUsing the Leaflet Package for R (Cheng et al. 2023), we can visualise the resulting rast\n\nplet(ts,\n     col=(c(\"darkblue\",\"pink\")),\n     legend=\"bottomright\",\n     main=\"LST (Cº)\",\n     tiles=c(\"Esri.WorldImagery\"))\n\n\n\n\n\n\n\n\n\n\n\nstack = c(ndvi, ndbi, ndwi, albedo, ts)\n\ndata_df = na.omit(as.data.frame(stack, xy=TRUE))\n\ndata_df$month = \"may\"\n\nnames(data_df) = c(\"X\", \"Y\", \n                   \"NDVI\",\"NDBI\",\n                   \"NDWI\", \"Albedo\", \"TS\",\n                   \"Month\")\n\n\nwrite_csv(data_df, \"may.csv\")"
  },
  {
    "objectID": "lsmay.html#loading-rasters",
    "href": "lsmay.html#loading-rasters",
    "title": "LandSat 8 May",
    "section": "",
    "text": "These rasters denote different bands of EM radiation captured by the LandSat 8 satellite over the south of Gran Canaria at 11:29am on the 18th May 2023 (U. S. Geological Surey 2023). These bands cover most of the visible light spectrum as well as the infrared spectrum. Combined in various was they can be used to calculate various measures such as the NDVI (normalised difference vegetation index) and the LST (land surface temperature).\nFirst lets plot and load the rasters\n\n# function to plot raster with a label and custome colour scale\nplot_rast = function(raster, label, colors) {\n  terra::plot(raster, col=colorRampPalette(colors)(100))\n  mtext(text=label, side=3, line=2)\n}\n\n# define the bounding box epsg:4083\nbbox = ext(c(437292.6282,445376.8775,3067829.6809,3072637.1023))\n\n# load each raster, crop to bounding box, and plot with label\nb2 = crop(rast(\"landsat_may/B2.TIF\"), bbox)\nb3 = crop(rast(\"landsat_may/B3.TIF\"), bbox)\nb4 = crop(rast(\"landsat_may/B4.TIF\"), bbox)\nb5 = crop(rast(\"landsat_may/B5.TIF\"), bbox)\nb6 = crop(rast(\"landsat_may/B6.TIF\"), bbox)\nb7 = crop(rast(\"landsat_may/B7.TIF\"), bbox)\nb10 = crop(rast(\"landsat_may/B10.TIF\"), bbox)"
  },
  {
    "objectID": "lsmay.html#loading-coast-shapefile",
    "href": "lsmay.html#loading-coast-shapefile",
    "title": "LandSat 8 May",
    "section": "",
    "text": "Using OSM Data to first extract a coastline of the island\n\n# query osm\ngran_canaria_query = opq(bbox = \"Gran Canaria\") %&gt;%\n  add_osm_feature(key = \"place\", value = \"island\") %&gt;%\n  osmdata_sf()\n# extract the coast data\ngran_canaria_sf = gran_canaria_query$osm_multipolygons\n\n# make spatial vector\ngran_canaria_vect = st_transform(gran_canaria_sf, crs(b2)) %&gt;%\n  vect()"
  },
  {
    "objectID": "lsmay.html#masking-ocean-values",
    "href": "lsmay.html#masking-ocean-values",
    "title": "LandSat 8 May",
    "section": "",
    "text": "b2 = mask(b2, gran_canaria_vect)\nb3 = mask(b3, gran_canaria_vect)\nb4 = mask(b4, gran_canaria_vect)\nb5 = mask(b5, gran_canaria_vect)\nb6 = mask(b6, gran_canaria_vect)\nb7 = mask(b7, gran_canaria_vect)\nb10 = mask(b10, gran_canaria_vect)"
  },
  {
    "objectID": "lsmay.html#calculating-ndvi",
    "href": "lsmay.html#calculating-ndvi",
    "title": "LandSat 8 May",
    "section": "",
    "text": "Perhaps the most important metric beside LST is NVDI. NDVI is also used in the computation of impassivity and ultimately therefore emissivity adjusted LST.\nTo calculate NDVI, the following formula is used:\n\\[\n\\text{NDVI} = \\frac{\\text{NIR} - \\text{Red}}{\\text{NIR} + \\text{Red}}\n\\]\nHere \\(NIR\\) represents the Near-Infrared band reflectance value, in Landsat 8 this is Band 5. Further \\(Red\\) represents the Red band reflectance value, in Landsat 8 this is Band 4.\n\n# calc and plot ndvi using bands 5 and 4\nndvi = (b5-b4)/(b5+b4)\n\nplot_rast(ndvi,\n          \"Normalised Difference Vegetation Index (NDVI)\",\n          c(\"brown\", \"green\"))"
  },
  {
    "objectID": "lsmay.html#calculating-ndbi",
    "href": "lsmay.html#calculating-ndbi",
    "title": "LandSat 8 May",
    "section": "",
    "text": "Another important metric is NDBI as urban artificial surfaces may trap heat causing excess heating relative to vegetated surfaces.\nTo calculate NDBI for Landsat 8, the following formula is used (Abulibdeh 2021):\n\\[\n\\text{NDVI} = \\frac{\\text{MIR} - \\text{NIR}}{\\text{MIR} + \\text{NIR}}\n\\]\nHere \\(NIR\\) again represents the Middle-Infrared band value, in Landsat 8 this is Band 5. Also \\(NIR\\) again represents the Near-Infrared band value, being Landsat 8 Band 5.\nHowever, we may not use this as for arid areas it has reduced efficacy. Instead we may rasterise OSM building data.\n\nndbi = (b6-b5)/(b6+b5)\n\nplot_rast(ndbi,\n          \"Normalised Difference Built Index (NDBI)\",\n          c(\"lightgreen\", \"black\"))"
  },
  {
    "objectID": "lsmay.html#calculating-ndwi",
    "href": "lsmay.html#calculating-ndwi",
    "title": "LandSat 8 May",
    "section": "",
    "text": "Complementing these metrics is NDWI, here used to analyse the impact that surface water has upon the temperature.\nTo calculate NWBI for Landsat 8, the following formula is used:\n\\[\n\\text{NDVI} = \\frac{\\text{Green} - \\text{SWIR}}{\\text{Green} + \\text{SWIR}}\n\\]\nHere \\(Green\\) represents the Green reflectance values, in Landsat 8 this is Band 3. Also \\(SWIR\\) again represents the Short-Infrared band value, being Landsat 8 Band 7.\n\n# calc and plot\nndwi = (b3-b7)/(b3+b7)\n\nplot_rast(ndwi,\n          \"Normalised Difference Water Index (NDWI)\",\n          c(\"yellow\", \"blue\"))"
  },
  {
    "objectID": "lsmay.html#calculating-surface-albedo",
    "href": "lsmay.html#calculating-surface-albedo",
    "title": "LandSat 8 May",
    "section": "",
    "text": "There is also surface albedo \\(\\alpha\\), which is the the fraction of the reflected shortwave radiation, is calculated using the following formula (Equere et al. 2021):\n\\[\n\\alpha = \\frac{0.356·\\text{Blue} + 0.0130 · \\text{Red} + 0.373 · \\text{NIR} + 0.085 * \\text{MIR} + 0.072 · \\text{SWIR} - 0.0018}{1.016}\n\\]\nHere \\(Blue\\) represents the Blue reflectance values, in Landsat 8 this is Band 2. \\(Red\\) again represents the Red band value, being Landsat 8 Band 4. \\(NIR\\) represents the Near-Infrared values, in Landsat 8 this is Band 5. \\(MIR\\) likewise represents the Middle-Infrared values, being Landsat 8 Band 6. Finally \\(SWIR\\) represents the Near-Infrared values, in Landsat 8 this is Band 7.\n\n# calc and plot\nalbedo = (0.356*b2+0.0130*b4+0.373*b5+0.085*b6+0.072*b7-0.0018)/1.016\n\nplot_rast(albedo,\n          expression(paste(\"Surface Albedo (\", alpha,\")\")),\n          c(\"pink\", \"blue\"))"
  },
  {
    "objectID": "lsmay.html#calculating-lst",
    "href": "lsmay.html#calculating-lst",
    "title": "LandSat 8 May",
    "section": "",
    "text": "Calculating LST can be straightforward in principle, using Band 10 alone of Landsat 8 data. However, this will not account for surface emissivity. Thus, for this study, an adjusted LST is calculated.\n\n\nThe first step is to convert the Digital Numbers \\(DN\\) in the Band 10 layer to Top of Atmosphere Spectral Radiance \\(L_\\lambda\\) values. This process uses input units found the images metadata/MLT file. These values are the RADIANCE_MULT_BAND_10 \\(M_L\\) and the RADIANCE_ADD_BAND_10 \\(\\text{A}_L\\).\nPutting these together into a formula is as follows:\n\\[\n\\text{L}_\\lambda = \\text{M}_L · \\text{DN} + \\text{A}_L\n\\]\n\n# define metadata values\nmult_b10 = 3.8e-04\nadd_b10 = 0.1\n\n# calc and plot\nl = (mult_b10*b10+add_b10)\n\nplot_rast(l,\n          expression(Spectral~Radiance~(L[lambda])),\n          c(\"brown\", \"yellow\"))\n\n\n\n\n\n\n\nThe second step is “Conversion of Radiance to At-Sensor Temperature” (Karyati et al. 2022). This This converts the Spectral Radiance into temperature values or Brightness Temperature \\(BT\\) in Kelvin. This process requires two constants related to Landsat 8 Band 10’s specific thermal conversion constants found again in the metadata file. These are \\(K1\\)and \\(K2\\).\nPutting this together into a formula is as follows:\n\\[\n\\text{BT} = \\frac{\\text{K2}}{ln(\\frac{\\text{K1}}{\\text{L}_\\lambda} + 1)}\n\\]\n\n# add effective wavelength of landsat b10\nk1 = 799.0284\nk2 = 1329.2405\n\n# calc and plot\nbt = (k2/log(k1/l+1))\n\nplot_rast(bt,\n          expression(Brightness~Temp~(BT)),\n          c(\"blue\", \"red\")) \n\n\n\n\n\n\n\nThe above metric alone could be used for study of heat distribution, however it does not account for the variation caused by surface level emissivity. Emissivity denotes how much infrared a surface will absorb or reflect, ranging from a mirror to a perfect black surface. The values of emissivity range from 0 to 1 respectively.\n\n\nNDVI is used to determine emissivity, through the fractional vegetation factor \\(\\text{P}_v\\). This value is specific to the region being studied.\nThe formula for calculating fractional vegetation factor is as follows:\n\\[\n\\text{P}_v = \\left( \\frac{\\text{NDVI} - \\text{NDVI}_{\\min}}{\\text{NDVI}_{\\max} - \\text{NDVI}_{\\min}} \\right)^2\n\\]\n\n# define min and max ndvi\nmin_ndvi = global(ndvi, fun=min, na.rm=TRUE) %&gt;%\n  as.numeric()\nmax_ndvi = global(ndvi, fun=max, na.rm=TRUE) %&gt;%\n  as.numeric()\n\n# calc and plot vegetation factor\npv = ((ndvi-min_ndvi)/(max_ndvi-min_ndvi))^2\n\nplot_rast(pv,\n          expression(Fractional~Vegetation~Factor~(P[v])),\n          c(\"maroon\", \"green\"))\n\n\n\n\n\n\n\nFrom this the surface emissivity can be calculated. This uses two constants relating to the relative emissivity of soil \\(\\epsilon\\text{s}\\lambda\\) and the emissivity of vegetation \\(\\epsilon\\text{v}\\lambda\\), as well as one surface roughness \\(\\text{C}\\lambda\\) metric of 0.005\nThe formula for estimating emissivity \\(\\epsilon\\lambda\\) is thus as follows:\n\\[\n\\epsilon\\lambda = \\epsilon\\text{v}\\lambda + \\epsilon\\text{s}\\lambda  · (1 - \\text{P}_v) + \\text{C}\\lambda\n\\]\n\n# soil emissivity\nes = 0.964\n\n# veg emissivity\nev = 0.984\n\n# calc and plot emissivity\ne =  ev*pv+es*(1-pv)+0.005\n\nplot_rast(e,\n          expression(Emissivity~(epsilon*lambda)),\n          c(\"yellow\", \"darkgreen\"))\n\n\n\n\n\n\n\n\nNow most of the building blocks are in place to calculate the adjusted LST. This requires a correction constant \\(\\rho\\) that incorporates the Speed of Light \\(c\\), Planck’s constant \\(h\\), and Boltzmann’s constant \\(\\sigma\\).\nThe formula for this is as follows:\n\\[\n\\rho = \\frac{c·h}{\\sigma}\n\\]\n\n# speed of light\nc = 2.997925e8 \n\n# planck's constant\nh = 6.626070e-34\n\n# boltzmann's constant\nsigma = 1.380649e-23\n\n# calc and output correction constant/rho \nrho = c*h/sigma\nrho\n\n[1] 0.01438777\n\n\n\n\n\nWith these building blocks, plus the wavelength of the emitted radiance for Landsat 8 \\(\\lambda\\), the adjusted LST \\(\\text{T}s\\) can be determined using the following formula (converting from Kelvin to Celcius:\n\\[\n\\text{T}_s = \\frac{\\text{BT}}{1 + (\\frac{\\lambda\\text{BT}}{\\rho} · ln(\\epsilon\\lambda))} - 273.15\n\\]\n\n# wavelength\nwl = 10.895e-6\n\n# calc and plot\nts = bt/(1+(wl*bt/rho)*log(e))-273.15\n\nplot_rast(ts,\n          expression(Land~Surface~Temperature~(T[s])), c(\"blue\", \"red\"))\n\n\n\n\n\n\nUsing the Leaflet Package for R (Cheng et al. 2023), we can visualise the resulting rast\n\nplet(ts,\n     col=(c(\"darkblue\",\"pink\")),\n     legend=\"bottomright\",\n     main=\"LST (Cº)\",\n     tiles=c(\"Esri.WorldImagery\"))"
  },
  {
    "objectID": "lsmay.html#stack-and-export",
    "href": "lsmay.html#stack-and-export",
    "title": "LandSat 8 May",
    "section": "",
    "text": "stack = c(ndvi, ndbi, ndwi, albedo, ts)\n\ndata_df = na.omit(as.data.frame(stack, xy=TRUE))\n\ndata_df$month = \"may\"\n\nnames(data_df) = c(\"X\", \"Y\", \n                   \"NDVI\",\"NDBI\",\n                   \"NDWI\", \"Albedo\", \"TS\",\n                   \"Month\")\n\n\nwrite_csv(data_df, \"may.csv\")"
  },
  {
    "objectID": "lsjanuary.html",
    "href": "lsjanuary.html",
    "title": "LandSat 8 January",
    "section": "",
    "text": "Here the LST and NDVI from LandSat 8 at 30m resolution is calculated for January 2023. This is in a similar process to Onačillová et al. (2022); Equere et al. (2021); Son et al. (2017); Karyati et al. (2022).\n\n# load packages\nlibrary(tidyverse)\nlibrary(terra)\nlibrary(RColorBrewer)\nlibrary(sf)\nlibrary(leaflet)\nlibrary(osmdata)\n\n\n\nThese rasters denote different bands of EM radiation captured by the LandSat 8 satellite over the south of Gran Canaria at 11:29am on the 5th January 2023 (U. S. Geological Surey 2023). These bands cover most of the visible light spectrum as well as the infrared spectrum. Combined in various was they can be used to calculate various measures such as the NDVI (normalised difference vegetation index) and the LST (land surface temperature).\nFirst lets plot and load the rasters\n\n# function to plot raster with a label and custome colour scale\nplot_rast = function(raster, label, colors) {\n  terra::plot(raster, col=colorRampPalette(colors)(100))\n  mtext(text=label, side=3, line=2)\n}\n\n# define the bounding box epsg:4083\nbbox = ext(c(437292.6282,445376.8775,3067829.6809,3072637.1023))\n\n# load each raster, crop to bounding box, and plot with label\nb2 = crop(rast(\"landsat_january/B2.TIF\"), bbox)\nb3 = crop(rast(\"landsat_january/B3.TIF\"), bbox)\nb4 = crop(rast(\"landsat_january/B4.TIF\"), bbox)\nb5 = crop(rast(\"landsat_january/B5.TIF\"), bbox)\nb6 = crop(rast(\"landsat_january/B6.TIF\"), bbox)\nb7 = crop(rast(\"landsat_january/B7.TIF\"), bbox)\nb10 = crop(rast(\"landsat_january/B10.TIF\"), bbox)\n\n\n\n\nUsing OSM Data to first extract a coastline of the island\n\n# query osm\ngran_canaria_query = opq(bbox = \"Gran Canaria\") %&gt;%\n  add_osm_feature(key = \"place\", value = \"island\") %&gt;%\n  osmdata_sf()\n# extract the coast data\ngran_canaria_sf = gran_canaria_query$osm_multipolygons\n\n# make spatial vector\ngran_canaria_vect = st_transform(gran_canaria_sf, crs(b2)) %&gt;%\n  vect()\n\n\n\n\n\nb2 = mask(b2, gran_canaria_vect)\nb3 = mask(b3, gran_canaria_vect)\nb4 = mask(b4, gran_canaria_vect)\nb5 = mask(b5, gran_canaria_vect)\nb6 = mask(b6, gran_canaria_vect)\nb7 = mask(b7, gran_canaria_vect)\nb10 = mask(b10, gran_canaria_vect)\n\n\n\n\nPerhaps the most important metric beside LST is NVDI. NDVI is also used in the computation of impassivity and ultimately therefore emissivity adjusted LST.\nTo calculate NDVI, the following formula is used:\n\\[\n\\text{NDVI} = \\frac{\\text{NIR} - \\text{Red}}{\\text{NIR} + \\text{Red}}\n\\]\nHere \\(NIR\\) represents the Near-Infrared band reflectance value, in Landsat 8 this is Band 5. Further \\(Red\\) represents the Red band reflectance value, in Landsat 8 this is Band 4.\n\n# calc and plot ndvi using bands 5 and 4\nndvi = (b5-b4)/(b5+b4)\n\nplot_rast(ndvi,\n          \"Normalised Difference Vegetation Index (NDVI)\",\n          c(\"brown\", \"green\"))\n\n\n\n\n\n\n\nAnother important metric is NDBI as urban artificial surfaces may trap heat causing excess heating relative to vegetated surfaces.\nTo calculate NDBI for Landsat 8, the following formula is used (Abulibdeh 2021):\n\\[\n\\text{NDVI} = \\frac{\\text{MIR} - \\text{NIR}}{\\text{MIR} + \\text{NIR}}\n\\]\nHere \\(NIR\\) again represents the Middle-Infrared band value, in Landsat 8 this is Band 5. Also \\(NIR\\) again represents the Near-Infrared band value, being Landsat 8 Band 5.\nHowever, we may not use this as for arid areas it has reduced efficacy. Instead we may rasterise OSM building data.\n\nndbi = (b6-b5)/(b6+b5)\n\nplot_rast(ndbi,\n          \"Normalised Difference Built Index (NDBI)\",\n          c(\"lightgreen\", \"black\"))\n\n\n\n\n\n\n\nComplementing these metrics is NDWI, here used to analyse the impact that surface water has upon the temperature.\nTo calculate NWBI for Landsat 8, the following formula is used:\n\\[\n\\text{NDVI} = \\frac{\\text{Green} - \\text{SWIR}}{\\text{Green} + \\text{SWIR}}\n\\]\nHere \\(Green\\) represents the Green reflectance values, in Landsat 8 this is Band 3. Also \\(SWIR\\) again represents the Short-Infrared band value, being Landsat 8 Band 7.\n\n# calc and plot\nndwi = (b3-b7)/(b3+b7)\n\nplot_rast(ndwi,\n          \"Normalised Difference Water Index (NDWI)\",\n          c(\"yellow\", \"blue\"))\n\n\n\n\n\n\n\nThere is also surface albedo \\(\\alpha\\), which is the the fraction of the reflected shortwave radiation, is calculated using the following formula (Equere et al. 2021):\n\\[\n\\alpha = \\frac{0.356·\\text{Blue} + 0.0130 · \\text{Red} + 0.373 · \\text{NIR} + 0.085 * \\text{MIR} + 0.072 · \\text{SWIR} - 0.0018}{1.016}\n\\]\nHere \\(Blue\\) represents the Blue reflectance values, in Landsat 8 this is Band 2. \\(Red\\) again represents the Red band value, being Landsat 8 Band 4. \\(NIR\\) represents the Near-Infrared values, in Landsat 8 this is Band 5. \\(MIR\\) likewise represents the Middle-Infrared values, being Landsat 8 Band 6. Finally \\(SWIR\\) represents the Near-Infrared values, in Landsat 8 this is Band 7.\n\n# calc and plot\nalbedo = (0.356*b2+0.0130*b4+0.373*b5+0.085*b6+0.072*b7-0.0018)/1.016\n\nplot_rast(albedo,\n          expression(paste(\"Surface Albedo (\", alpha,\")\")),\n          c(\"pink\", \"blue\"))\n\n\n\n\n\n\n\nCalculating LST can be straightforward in principle, using Band 10 alone of Landsat 8 data. However, this will not account for surface emissivity. Thus, for this study, an adjusted LST is calculated.\n\n\nThe first step is to convert the Digital Numbers \\(DN\\) in the Band 10 layer to Top of Atmosphere Spectral Radiance \\(L_\\lambda\\) values. This process uses input units found the images metadata/MLT file. These values are the RADIANCE_MULT_BAND_10 \\(M_L\\) and the RADIANCE_ADD_BAND_10 \\(\\text{A}_L\\).\nPutting these together into a formula is as follows:\n\\[\n\\text{L}_\\lambda = \\text{M}_L · \\text{DN} + \\text{A}_L\n\\]\n\n# define metadata values\nmult_b10 = 3.8e-04\nadd_b10 = 0.1\n\n# calc and plot\nl = (mult_b10*b10+add_b10)\n\nplot_rast(l,\n          expression(Spectral~Radiance~(L[lambda])),\n          c(\"brown\", \"yellow\"))\n\n\n\n\n\n\n\nThe second step is “Conversion of Radiance to At-Sensor Temperature” (Karyati et al. 2022). This This converts the Spectral Radiance into temperature values or Brightness Temperature \\(BT\\) in Kelvin. This process requires two constants related to Landsat 8 Band 10’s specific thermal conversion constants found again in the metadata file. These are \\(K1\\)and \\(K2\\).\nPutting this together into a formula is as follows:\n\\[\n\\text{BT} = \\frac{\\text{K2}}{ln(\\frac{\\text{K1}}{\\text{L}_\\lambda} + 1)}\n\\]\n\n# add effective wavelength of landsat b10\nk1 = 799.0284\nk2 = 1329.2405\n\n# calc and plot\nbt = (k2/log(k1/l+1))\n\nplot_rast(bt,\n          expression(Brightness~Temp~(BT)),\n          c(\"blue\", \"red\")) \n\n\n\n\n\n\n\nThe above metric alone could be used for study of heat distribution, however it does not account for the variation caused by surface level emissivity. Emissivity denotes how much infrared a surface will absorb or reflect, ranging from a mirror to a perfect black surface. The values of emissivity range from 0 to 1 respectively.\n\n\nNDVI is used to determine emissivity, through the fractional vegetation factor \\(\\text{P}_v\\). This value is specific to the region being studied.\nThe formula for calculating fractional vegetation factor is as follows:\n\\[\n\\text{P}_v = \\left( \\frac{\\text{NDVI} - \\text{NDVI}_{\\min}}{\\text{NDVI}_{\\max} - \\text{NDVI}_{\\min}} \\right)^2\n\\]\n\n# define min and max ndvi\nmin_ndvi = global(ndvi, fun=min, na.rm=TRUE) %&gt;%\n  as.numeric()\nmax_ndvi = global(ndvi, fun=max, na.rm=TRUE) %&gt;%\n  as.numeric()\n\n# calc and plot vegetation factor\npv = ((ndvi-min_ndvi)/(max_ndvi-min_ndvi))^2\n\nplot_rast(pv,\n          expression(Fractional~Vegetation~Factor~(P[v])),\n          c(\"maroon\", \"green\"))\n\n\n\n\n\n\n\nFrom this the surface emissivity can be calculated. This uses two constants relating to the relative emissivity of soil \\(\\epsilon\\text{s}\\lambda\\) and the emissivity of vegetation \\(\\epsilon\\text{v}\\lambda\\), as well as one surface roughness \\(\\text{C}\\lambda\\) metric of 0.005\nThe formula for estimating emissivity \\(\\epsilon\\lambda\\) is thus as follows:\n\\[\n\\epsilon\\lambda = \\epsilon\\text{v}\\lambda + \\epsilon\\text{s}\\lambda  · (1 - \\text{P}_v) + \\text{C}\\lambda\n\\]\n\n# soil emissivity\nes = 0.964\n\n# veg emissivity\nev = 0.984\n\n# calc and plot emissivity\ne =  ev*pv+es*(1-pv)+0.005\n\nplot_rast(e,\n          expression(Emissivity~(epsilon*lambda)),\n          c(\"yellow\", \"darkgreen\"))\n\n\n\n\n\n\n\n\nNow most of the building blocks are in place to calculate the adjusted LST. This requires a correction constant \\(\\rho\\) that incorporates the Speed of Light \\(c\\), Planck’s constant \\(h\\), and Boltzmann’s constant \\(\\sigma\\).\nThe formula for this is as follows:\n\\[\n\\rho = \\frac{c·h}{\\sigma}\n\\]\n\n# speed of light\nc = 2.997925e8 \n\n# planck's constant\nh = 6.626070e-34\n\n# boltzmann's constant\nsigma = 1.380649e-23\n\n# calc and output correction constant/rho \nrho = c*h/sigma\nrho\n\n[1] 0.01438777\n\n\n\n\n\nWith these building blocks, plus the wavelength of the emitted radiance for Landsat 8 \\(\\lambda\\), the adjusted LST \\(\\text{T}s\\) can be determined using the following formula (converting from Kelvin to Celcius:\n\\[\n\\text{T}_s = \\frac{\\text{BT}}{1 + (\\frac{\\lambda\\text{BT}}{\\rho} · ln(\\epsilon\\lambda))} - 273.15\n\\]\n\n# wavelength\nwl = 10.895e-6\n\n# calc and plot\nts = bt/(1+(wl*bt/rho)*log(e))-273.15\n\nplot_rast(ts,\n          expression(Land~Surface~Temperature~(T[s])), c(\"blue\", \"red\"))\n\n\n\n\n\n\nUsing the Leaflet Package for R (Cheng et al. 2023), we can visualise the resulting rast\n\nplet(ts,\n     col=(c(\"darkblue\",\"pink\")),\n     legend=\"bottomright\",\n     main=\"LST (Cº)\",\n     tiles=c(\"Esri.WorldImagery\"))\n\n\n\n\n\n\n\n\n\n\n\nstack = c(ndvi, ndbi, ndwi, albedo, ts)\n\ndata_df = na.omit(as.data.frame(stack, xy=TRUE))\n\ndata_df$month = \"january\"\n\nnames(data_df) = c(\"X\", \"Y\", \n                   \"NDVI\",\"NDBI\",\n                   \"NDWI\", \"Albedo\", \"TS\",\n                   \"Month\")\n\n\nwrite_csv(data_df, \"january.csv\")"
  },
  {
    "objectID": "lsjanuary.html#loading-rasters",
    "href": "lsjanuary.html#loading-rasters",
    "title": "LandSat 8 January",
    "section": "",
    "text": "These rasters denote different bands of EM radiation captured by the LandSat 8 satellite over the south of Gran Canaria at 11:29am on the 5th January 2023 (U. S. Geological Surey 2023). These bands cover most of the visible light spectrum as well as the infrared spectrum. Combined in various was they can be used to calculate various measures such as the NDVI (normalised difference vegetation index) and the LST (land surface temperature).\nFirst lets plot and load the rasters\n\n# function to plot raster with a label and custome colour scale\nplot_rast = function(raster, label, colors) {\n  terra::plot(raster, col=colorRampPalette(colors)(100))\n  mtext(text=label, side=3, line=2)\n}\n\n# define the bounding box epsg:4083\nbbox = ext(c(437292.6282,445376.8775,3067829.6809,3072637.1023))\n\n# load each raster, crop to bounding box, and plot with label\nb2 = crop(rast(\"landsat_january/B2.TIF\"), bbox)\nb3 = crop(rast(\"landsat_january/B3.TIF\"), bbox)\nb4 = crop(rast(\"landsat_january/B4.TIF\"), bbox)\nb5 = crop(rast(\"landsat_january/B5.TIF\"), bbox)\nb6 = crop(rast(\"landsat_january/B6.TIF\"), bbox)\nb7 = crop(rast(\"landsat_january/B7.TIF\"), bbox)\nb10 = crop(rast(\"landsat_january/B10.TIF\"), bbox)"
  },
  {
    "objectID": "lsjanuary.html#loading-coast-shapefile",
    "href": "lsjanuary.html#loading-coast-shapefile",
    "title": "LandSat 8 January",
    "section": "",
    "text": "Using OSM Data to first extract a coastline of the island\n\n# query osm\ngran_canaria_query = opq(bbox = \"Gran Canaria\") %&gt;%\n  add_osm_feature(key = \"place\", value = \"island\") %&gt;%\n  osmdata_sf()\n# extract the coast data\ngran_canaria_sf = gran_canaria_query$osm_multipolygons\n\n# make spatial vector\ngran_canaria_vect = st_transform(gran_canaria_sf, crs(b2)) %&gt;%\n  vect()"
  },
  {
    "objectID": "lsjanuary.html#masking-ocean-values",
    "href": "lsjanuary.html#masking-ocean-values",
    "title": "LandSat 8 January",
    "section": "",
    "text": "b2 = mask(b2, gran_canaria_vect)\nb3 = mask(b3, gran_canaria_vect)\nb4 = mask(b4, gran_canaria_vect)\nb5 = mask(b5, gran_canaria_vect)\nb6 = mask(b6, gran_canaria_vect)\nb7 = mask(b7, gran_canaria_vect)\nb10 = mask(b10, gran_canaria_vect)"
  },
  {
    "objectID": "lsjanuary.html#calculating-ndvi",
    "href": "lsjanuary.html#calculating-ndvi",
    "title": "LandSat 8 January",
    "section": "",
    "text": "Perhaps the most important metric beside LST is NVDI. NDVI is also used in the computation of impassivity and ultimately therefore emissivity adjusted LST.\nTo calculate NDVI, the following formula is used:\n\\[\n\\text{NDVI} = \\frac{\\text{NIR} - \\text{Red}}{\\text{NIR} + \\text{Red}}\n\\]\nHere \\(NIR\\) represents the Near-Infrared band reflectance value, in Landsat 8 this is Band 5. Further \\(Red\\) represents the Red band reflectance value, in Landsat 8 this is Band 4.\n\n# calc and plot ndvi using bands 5 and 4\nndvi = (b5-b4)/(b5+b4)\n\nplot_rast(ndvi,\n          \"Normalised Difference Vegetation Index (NDVI)\",\n          c(\"brown\", \"green\"))"
  },
  {
    "objectID": "lsjanuary.html#calculating-ndbi",
    "href": "lsjanuary.html#calculating-ndbi",
    "title": "LandSat 8 January",
    "section": "",
    "text": "Another important metric is NDBI as urban artificial surfaces may trap heat causing excess heating relative to vegetated surfaces.\nTo calculate NDBI for Landsat 8, the following formula is used (Abulibdeh 2021):\n\\[\n\\text{NDVI} = \\frac{\\text{MIR} - \\text{NIR}}{\\text{MIR} + \\text{NIR}}\n\\]\nHere \\(NIR\\) again represents the Middle-Infrared band value, in Landsat 8 this is Band 5. Also \\(NIR\\) again represents the Near-Infrared band value, being Landsat 8 Band 5.\nHowever, we may not use this as for arid areas it has reduced efficacy. Instead we may rasterise OSM building data.\n\nndbi = (b6-b5)/(b6+b5)\n\nplot_rast(ndbi,\n          \"Normalised Difference Built Index (NDBI)\",\n          c(\"lightgreen\", \"black\"))"
  },
  {
    "objectID": "lsjanuary.html#calculating-ndwi",
    "href": "lsjanuary.html#calculating-ndwi",
    "title": "LandSat 8 January",
    "section": "",
    "text": "Complementing these metrics is NDWI, here used to analyse the impact that surface water has upon the temperature.\nTo calculate NWBI for Landsat 8, the following formula is used:\n\\[\n\\text{NDVI} = \\frac{\\text{Green} - \\text{SWIR}}{\\text{Green} + \\text{SWIR}}\n\\]\nHere \\(Green\\) represents the Green reflectance values, in Landsat 8 this is Band 3. Also \\(SWIR\\) again represents the Short-Infrared band value, being Landsat 8 Band 7.\n\n# calc and plot\nndwi = (b3-b7)/(b3+b7)\n\nplot_rast(ndwi,\n          \"Normalised Difference Water Index (NDWI)\",\n          c(\"yellow\", \"blue\"))"
  },
  {
    "objectID": "lsjanuary.html#calculating-surface-albedo",
    "href": "lsjanuary.html#calculating-surface-albedo",
    "title": "LandSat 8 January",
    "section": "",
    "text": "There is also surface albedo \\(\\alpha\\), which is the the fraction of the reflected shortwave radiation, is calculated using the following formula (Equere et al. 2021):\n\\[\n\\alpha = \\frac{0.356·\\text{Blue} + 0.0130 · \\text{Red} + 0.373 · \\text{NIR} + 0.085 * \\text{MIR} + 0.072 · \\text{SWIR} - 0.0018}{1.016}\n\\]\nHere \\(Blue\\) represents the Blue reflectance values, in Landsat 8 this is Band 2. \\(Red\\) again represents the Red band value, being Landsat 8 Band 4. \\(NIR\\) represents the Near-Infrared values, in Landsat 8 this is Band 5. \\(MIR\\) likewise represents the Middle-Infrared values, being Landsat 8 Band 6. Finally \\(SWIR\\) represents the Near-Infrared values, in Landsat 8 this is Band 7.\n\n# calc and plot\nalbedo = (0.356*b2+0.0130*b4+0.373*b5+0.085*b6+0.072*b7-0.0018)/1.016\n\nplot_rast(albedo,\n          expression(paste(\"Surface Albedo (\", alpha,\")\")),\n          c(\"pink\", \"blue\"))"
  },
  {
    "objectID": "lsjanuary.html#calculating-lst",
    "href": "lsjanuary.html#calculating-lst",
    "title": "LandSat 8 January",
    "section": "",
    "text": "Calculating LST can be straightforward in principle, using Band 10 alone of Landsat 8 data. However, this will not account for surface emissivity. Thus, for this study, an adjusted LST is calculated.\n\n\nThe first step is to convert the Digital Numbers \\(DN\\) in the Band 10 layer to Top of Atmosphere Spectral Radiance \\(L_\\lambda\\) values. This process uses input units found the images metadata/MLT file. These values are the RADIANCE_MULT_BAND_10 \\(M_L\\) and the RADIANCE_ADD_BAND_10 \\(\\text{A}_L\\).\nPutting these together into a formula is as follows:\n\\[\n\\text{L}_\\lambda = \\text{M}_L · \\text{DN} + \\text{A}_L\n\\]\n\n# define metadata values\nmult_b10 = 3.8e-04\nadd_b10 = 0.1\n\n# calc and plot\nl = (mult_b10*b10+add_b10)\n\nplot_rast(l,\n          expression(Spectral~Radiance~(L[lambda])),\n          c(\"brown\", \"yellow\"))\n\n\n\n\n\n\n\nThe second step is “Conversion of Radiance to At-Sensor Temperature” (Karyati et al. 2022). This This converts the Spectral Radiance into temperature values or Brightness Temperature \\(BT\\) in Kelvin. This process requires two constants related to Landsat 8 Band 10’s specific thermal conversion constants found again in the metadata file. These are \\(K1\\)and \\(K2\\).\nPutting this together into a formula is as follows:\n\\[\n\\text{BT} = \\frac{\\text{K2}}{ln(\\frac{\\text{K1}}{\\text{L}_\\lambda} + 1)}\n\\]\n\n# add effective wavelength of landsat b10\nk1 = 799.0284\nk2 = 1329.2405\n\n# calc and plot\nbt = (k2/log(k1/l+1))\n\nplot_rast(bt,\n          expression(Brightness~Temp~(BT)),\n          c(\"blue\", \"red\")) \n\n\n\n\n\n\n\nThe above metric alone could be used for study of heat distribution, however it does not account for the variation caused by surface level emissivity. Emissivity denotes how much infrared a surface will absorb or reflect, ranging from a mirror to a perfect black surface. The values of emissivity range from 0 to 1 respectively.\n\n\nNDVI is used to determine emissivity, through the fractional vegetation factor \\(\\text{P}_v\\). This value is specific to the region being studied.\nThe formula for calculating fractional vegetation factor is as follows:\n\\[\n\\text{P}_v = \\left( \\frac{\\text{NDVI} - \\text{NDVI}_{\\min}}{\\text{NDVI}_{\\max} - \\text{NDVI}_{\\min}} \\right)^2\n\\]\n\n# define min and max ndvi\nmin_ndvi = global(ndvi, fun=min, na.rm=TRUE) %&gt;%\n  as.numeric()\nmax_ndvi = global(ndvi, fun=max, na.rm=TRUE) %&gt;%\n  as.numeric()\n\n# calc and plot vegetation factor\npv = ((ndvi-min_ndvi)/(max_ndvi-min_ndvi))^2\n\nplot_rast(pv,\n          expression(Fractional~Vegetation~Factor~(P[v])),\n          c(\"maroon\", \"green\"))\n\n\n\n\n\n\n\nFrom this the surface emissivity can be calculated. This uses two constants relating to the relative emissivity of soil \\(\\epsilon\\text{s}\\lambda\\) and the emissivity of vegetation \\(\\epsilon\\text{v}\\lambda\\), as well as one surface roughness \\(\\text{C}\\lambda\\) metric of 0.005\nThe formula for estimating emissivity \\(\\epsilon\\lambda\\) is thus as follows:\n\\[\n\\epsilon\\lambda = \\epsilon\\text{v}\\lambda + \\epsilon\\text{s}\\lambda  · (1 - \\text{P}_v) + \\text{C}\\lambda\n\\]\n\n# soil emissivity\nes = 0.964\n\n# veg emissivity\nev = 0.984\n\n# calc and plot emissivity\ne =  ev*pv+es*(1-pv)+0.005\n\nplot_rast(e,\n          expression(Emissivity~(epsilon*lambda)),\n          c(\"yellow\", \"darkgreen\"))\n\n\n\n\n\n\n\n\nNow most of the building blocks are in place to calculate the adjusted LST. This requires a correction constant \\(\\rho\\) that incorporates the Speed of Light \\(c\\), Planck’s constant \\(h\\), and Boltzmann’s constant \\(\\sigma\\).\nThe formula for this is as follows:\n\\[\n\\rho = \\frac{c·h}{\\sigma}\n\\]\n\n# speed of light\nc = 2.997925e8 \n\n# planck's constant\nh = 6.626070e-34\n\n# boltzmann's constant\nsigma = 1.380649e-23\n\n# calc and output correction constant/rho \nrho = c*h/sigma\nrho\n\n[1] 0.01438777\n\n\n\n\n\nWith these building blocks, plus the wavelength of the emitted radiance for Landsat 8 \\(\\lambda\\), the adjusted LST \\(\\text{T}s\\) can be determined using the following formula (converting from Kelvin to Celcius:\n\\[\n\\text{T}_s = \\frac{\\text{BT}}{1 + (\\frac{\\lambda\\text{BT}}{\\rho} · ln(\\epsilon\\lambda))} - 273.15\n\\]\n\n# wavelength\nwl = 10.895e-6\n\n# calc and plot\nts = bt/(1+(wl*bt/rho)*log(e))-273.15\n\nplot_rast(ts,\n          expression(Land~Surface~Temperature~(T[s])), c(\"blue\", \"red\"))\n\n\n\n\n\n\nUsing the Leaflet Package for R (Cheng et al. 2023), we can visualise the resulting rast\n\nplet(ts,\n     col=(c(\"darkblue\",\"pink\")),\n     legend=\"bottomright\",\n     main=\"LST (Cº)\",\n     tiles=c(\"Esri.WorldImagery\"))"
  },
  {
    "objectID": "lsjanuary.html#stack-and-export",
    "href": "lsjanuary.html#stack-and-export",
    "title": "LandSat 8 January",
    "section": "",
    "text": "stack = c(ndvi, ndbi, ndwi, albedo, ts)\n\ndata_df = na.omit(as.data.frame(stack, xy=TRUE))\n\ndata_df$month = \"january\"\n\nnames(data_df) = c(\"X\", \"Y\", \n                   \"NDVI\",\"NDBI\",\n                   \"NDWI\", \"Albedo\", \"TS\",\n                   \"Month\")\n\n\nwrite_csv(data_df, \"january.csv\")"
  },
  {
    "objectID": "lsmarch.html",
    "href": "lsmarch.html",
    "title": "LandSat 8 March",
    "section": "",
    "text": "Here the LST and NDVI from LandSat 8 at 30m resolution is calculated for March 2023. This is in a similar process to Onačillová et al. (2022); Equere et al. (2021); Son et al. (2017); Karyati et al. (2022).\n\n# load packages\nlibrary(tidyverse)\nlibrary(terra)\nlibrary(RColorBrewer)\nlibrary(sf)\nlibrary(leaflet)\nlibrary(osmdata)\n\n\n\nThese rasters denote different bands of EM radiation captured by the LandSat 8 satellite over the south of Gran Canaria at 11:29am on the 20th March 2023 (U. S. Geological Surey 2023). These bands cover most of the visible light spectrum as well as the infrared spectrum. Combined in various was they can be used to calculate various measures such as the NDVI (normalised difference vegetation index) and the LST (land surface temperature).\nFirst lets plot and load the rasters\n\n# function to plot raster with a label and custome colour scale\nplot_rast = function(raster, label, colors) {\n  terra::plot(raster, col=colorRampPalette(colors)(100))\n  mtext(text=label, side=3, line=2)\n}\n\n# define the bounding box epsg:4083\nbbox = ext(c(437292.6282,445376.8775,3067829.6809,3072637.1023))\n\n# load each raster, crop to bounding box, and plot with label\nb2 = crop(rast(\"landsat_march/B2.TIF\"), bbox)\nb3 = crop(rast(\"landsat_march/B3.TIF\"), bbox)\nb4 = crop(rast(\"landsat_march/B4.TIF\"), bbox)\nb5 = crop(rast(\"landsat_march/B5.TIF\"), bbox)\nb6 = crop(rast(\"landsat_march/B6.TIF\"), bbox)\nb7 = crop(rast(\"landsat_march/B7.TIF\"), bbox)\nb10 = crop(rast(\"landsat_march/B10.TIF\"), bbox)\n\n\n\n\nUsing OSM Data to first extract a coastline of the island\n\n# query osm\ngran_canaria_query = opq(bbox = \"Gran Canaria\") %&gt;%\n  add_osm_feature(key = \"place\", value = \"island\") %&gt;%\n  osmdata_sf()\n# extract the coast data\ngran_canaria_sf = gran_canaria_query$osm_multipolygons\n\n# make spatial vector\ngran_canaria_vect = st_transform(gran_canaria_sf, crs(b2)) %&gt;%\n  vect()\n\n\n\n\n\nb2 = mask(b2, gran_canaria_vect)\nb3 = mask(b3, gran_canaria_vect)\nb4 = mask(b4, gran_canaria_vect)\nb5 = mask(b5, gran_canaria_vect)\nb6 = mask(b6, gran_canaria_vect)\nb7 = mask(b7, gran_canaria_vect)\nb10 = mask(b10, gran_canaria_vect)\n\n\n\n\nPerhaps the most important metric beside LST is NVDI. NDVI is also used in the computation of impassivity and ultimately therefore emissivity adjusted LST.\nTo calculate NDVI, the following formula is used:\n\\[\n\\text{NDVI} = \\frac{\\text{NIR} - \\text{Red}}{\\text{NIR} + \\text{Red}}\n\\]\nHere \\(NIR\\) represents the Near-Infrared band reflectance value, in Landsat 8 this is Band 5. Further \\(Red\\) represents the Red band reflectance value, in Landsat 8 this is Band 4.\n\n# calc and plot ndvi using bands 5 and 4\nndvi = (b5-b4)/(b5+b4)\n\nplot_rast(ndvi,\n          \"Normalised Difference Vegetation Index (NDVI)\",\n          c(\"brown\", \"green\"))\n\n\n\n\n\n\n\nAnother important metric is NDBI as urban artificial surfaces may trap heat causing excess heating relative to vegetated surfaces.\nTo calculate NDBI for Landsat 8, the following formula is used (Abulibdeh 2021):\n\\[\n\\text{NDVI} = \\frac{\\text{MIR} - \\text{NIR}}{\\text{MIR} + \\text{NIR}}\n\\]\nHere \\(NIR\\) again represents the Middle-Infrared band value, in Landsat 8 this is Band 5. Also \\(NIR\\) again represents the Near-Infrared band value, being Landsat 8 Band 5.\nHowever, we may not use this as for arid areas it has reduced efficacy. Instead we may rasterise OSM building data.\n\nndbi = (b6-b5)/(b6+b5)\n\nplot_rast(ndbi,\n          \"Normalised Difference Built Index (NDBI)\",\n          c(\"lightgreen\", \"black\"))\n\n\n\n\n\n\n\nComplementing these metrics is NDWI, here used to analyse the impact that surface water has upon the temperature.\nTo calculate NWBI for Landsat 8, the following formula is used:\n\\[\n\\text{NDVI} = \\frac{\\text{Green} - \\text{SWIR}}{\\text{Green} + \\text{SWIR}}\n\\]\nHere \\(Green\\) represents the Green reflectance values, in Landsat 8 this is Band 3. Also \\(SWIR\\) again represents the Short-Infrared band value, being Landsat 8 Band 7.\n\n# calc and plot\nndwi = (b3-b7)/(b3+b7)\n\nplot_rast(ndwi,\n          \"Normalised Difference Water Index (NDWI)\",\n          c(\"yellow\", \"blue\"))\n\n\n\n\n\n\n\nThere is also surface albedo \\(\\alpha\\), which is the the fraction of the reflected shortwave radiation, is calculated using the following formula (Equere et al. 2021):\n\\[\n\\alpha = \\frac{0.356·\\text{Blue} + 0.0130 · \\text{Red} + 0.373 · \\text{NIR} + 0.085 * \\text{MIR} + 0.072 · \\text{SWIR} - 0.0018}{1.016}\n\\]\nHere \\(Blue\\) represents the Blue reflectance values, in Landsat 8 this is Band 2. \\(Red\\) again represents the Red band value, being Landsat 8 Band 4. \\(NIR\\) represents the Near-Infrared values, in Landsat 8 this is Band 5. \\(MIR\\) likewise represents the Middle-Infrared values, being Landsat 8 Band 6. Finally \\(SWIR\\) represents the Near-Infrared values, in Landsat 8 this is Band 7.\n\n# calc and plot\nalbedo = (0.356*b2+0.0130*b4+0.373*b5+0.085*b6+0.072*b7-0.0018)/1.016\n\nplot_rast(albedo,\n          expression(paste(\"Surface Albedo (\", alpha,\")\")),\n          c(\"pink\", \"blue\"))\n\n\n\n\n\n\n\nCalculating LST can be straightforward in principle, using Band 10 alone of Landsat 8 data. However, this will not account for surface emissivity. Thus, for this study, an adjusted LST is calculated.\n\n\nThe first step is to convert the Digital Numbers \\(DN\\) in the Band 10 layer to Top of Atmosphere Spectral Radiance \\(L_\\lambda\\) values. This process uses input units found the images metadata/MLT file. These values are the RADIANCE_MULT_BAND_10 \\(M_L\\) and the RADIANCE_ADD_BAND_10 \\(\\text{A}_L\\).\nPutting these together into a formula is as follows:\n\\[\n\\text{L}_\\lambda = \\text{M}_L · \\text{DN} + \\text{A}_L\n\\]\n\n# define metadata values\nmult_b10 = 3.8e-04\nadd_b10 = 0.1\n\n# calc and plot\nl = (mult_b10*b10+add_b10)\n\nplot_rast(l,\n          expression(Spectral~Radiance~(L[lambda])),\n          c(\"brown\", \"yellow\"))\n\n\n\n\n\n\n\nThe second step is “Conversion of Radiance to At-Sensor Temperature” (Karyati et al. 2022). This This converts the Spectral Radiance into temperature values or Brightness Temperature \\(BT\\) in Kelvin. This process requires two constants related to Landsat 8 Band 10’s specific thermal conversion constants found again in the metadata file. These are \\(K1\\)and \\(K2\\).\nPutting this together into a formula is as follows:\n\\[\n\\text{BT} = \\frac{\\text{K2}}{ln(\\frac{\\text{K1}}{\\text{L}_\\lambda} + 1)}\n\\]\n\n# add effective wavelength of landsat b10\nk1 = 799.0284\nk2 = 1329.2405\n\n# calc and plot\nbt = (k2/log(k1/l+1))\n\nplot_rast(bt,\n          expression(Brightness~Temp~(BT)),\n          c(\"blue\", \"red\")) \n\n\n\n\n\n\n\nThe above metric alone could be used for study of heat distribution, however it does not account for the variation caused by surface level emissivity. Emissivity denotes how much infrared a surface will absorb or reflect, ranging from a mirror to a perfect black surface. The values of emissivity range from 0 to 1 respectively.\n\n\nNDVI is used to determine emissivity, through the fractional vegetation factor \\(\\text{P}_v\\). This value is specific to the region being studied.\nThe formula for calculating fractional vegetation factor is as follows:\n\\[\n\\text{P}_v = \\left( \\frac{\\text{NDVI} - \\text{NDVI}_{\\min}}{\\text{NDVI}_{\\max} - \\text{NDVI}_{\\min}} \\right)^2\n\\]\n\n# define min and max ndvi\nmin_ndvi = global(ndvi, fun=min, na.rm=TRUE) %&gt;%\n  as.numeric()\nmax_ndvi = global(ndvi, fun=max, na.rm=TRUE) %&gt;%\n  as.numeric()\n\n# calc and plot vegetation factor\npv = ((ndvi-min_ndvi)/(max_ndvi-min_ndvi))^2\n\nplot_rast(pv,\n          expression(Fractional~Vegetation~Factor~(P[v])),\n          c(\"maroon\", \"green\"))\n\n\n\n\n\n\n\nFrom this the surface emissivity can be calculated. This uses two constants relating to the relative emissivity of soil \\(\\epsilon\\text{s}\\lambda\\) and the emissivity of vegetation \\(\\epsilon\\text{v}\\lambda\\), as well as one surface roughness \\(\\text{C}\\lambda\\) metric of 0.005\nThe formula for estimating emissivity \\(\\epsilon\\lambda\\) is thus as follows:\n\\[\n\\epsilon\\lambda = \\epsilon\\text{v}\\lambda + \\epsilon\\text{s}\\lambda  · (1 - \\text{P}_v) + \\text{C}\\lambda\n\\]\n\n# soil emissivity\nes = 0.964\n\n# veg emissivity\nev = 0.984\n\n# calc and plot emissivity\ne =  ev*pv+es*(1-pv)+0.005\n\nplot_rast(e,\n          expression(Emissivity~(epsilon*lambda)),\n          c(\"yellow\", \"darkgreen\"))\n\n\n\n\n\n\n\n\nNow most of the building blocks are in place to calculate the adjusted LST. This requires a correction constant \\(\\rho\\) that incorporates the Speed of Light \\(c\\), Planck’s constant \\(h\\), and Boltzmann’s constant \\(\\sigma\\).\nThe formula for this is as follows:\n\\[\n\\rho = \\frac{c·h}{\\sigma}\n\\]\n\n# speed of light\nc = 2.997925e8 \n\n# planck's constant\nh = 6.626070e-34\n\n# boltzmann's constant\nsigma = 1.380649e-23\n\n# calc and output correction constant/rho \nrho = c*h/sigma\nrho\n\n[1] 0.01438777\n\n\n\n\n\nWith these building blocks, plus the wavelength of the emitted radiance for Landsat 8 \\(\\lambda\\), the adjusted LST \\(\\text{T}s\\) can be determined using the following formula (converting from Kelvin to Celcius:\n\\[\n\\text{T}_s = \\frac{\\text{BT}}{1 + (\\frac{\\lambda\\text{BT}}{\\rho} · ln(\\epsilon\\lambda))} - 273.15\n\\]\n\n# wavelength\nwl = 10.895e-6\n\n# calc and plot\nts = bt/(1+(wl*bt/rho)*log(e))-273.15\n\nplot_rast(ts,\n          expression(Land~Surface~Temperature~(T[s])), c(\"blue\", \"red\"))\n\n\n\n\n\n\nUsing the Leaflet Package for R (Cheng et al. 2023), we can visualise the resulting rast\n\nplet(ts,\n     col=(c(\"darkblue\",\"pink\")),\n     legend=\"bottomright\",\n     main=\"LST (Cº)\",\n     tiles=c(\"Esri.WorldImagery\"))\n\n\n\n\n\n\n\n\n\n\n\nstack = c(ndvi, ndbi, ndwi, albedo, ts)\n\ndata_df = na.omit(as.data.frame(stack, xy=TRUE))\n\ndata_df$month = \"march\"\n\nnames(data_df) = c(\"X\", \"Y\", \n                   \"NDVI\",\"NDBI\",\n                   \"NDWI\", \"Albedo\", \"TS\",\n                   \"Month\")\n\nwrite_csv(data_df, \"march.csv\")"
  },
  {
    "objectID": "lsmarch.html#loading-rasters",
    "href": "lsmarch.html#loading-rasters",
    "title": "LandSat 8 March",
    "section": "",
    "text": "These rasters denote different bands of EM radiation captured by the LandSat 8 satellite over the south of Gran Canaria at 11:29am on the 20th March 2023 (U. S. Geological Surey 2023). These bands cover most of the visible light spectrum as well as the infrared spectrum. Combined in various was they can be used to calculate various measures such as the NDVI (normalised difference vegetation index) and the LST (land surface temperature).\nFirst lets plot and load the rasters\n\n# function to plot raster with a label and custome colour scale\nplot_rast = function(raster, label, colors) {\n  terra::plot(raster, col=colorRampPalette(colors)(100))\n  mtext(text=label, side=3, line=2)\n}\n\n# define the bounding box epsg:4083\nbbox = ext(c(437292.6282,445376.8775,3067829.6809,3072637.1023))\n\n# load each raster, crop to bounding box, and plot with label\nb2 = crop(rast(\"landsat_march/B2.TIF\"), bbox)\nb3 = crop(rast(\"landsat_march/B3.TIF\"), bbox)\nb4 = crop(rast(\"landsat_march/B4.TIF\"), bbox)\nb5 = crop(rast(\"landsat_march/B5.TIF\"), bbox)\nb6 = crop(rast(\"landsat_march/B6.TIF\"), bbox)\nb7 = crop(rast(\"landsat_march/B7.TIF\"), bbox)\nb10 = crop(rast(\"landsat_march/B10.TIF\"), bbox)"
  },
  {
    "objectID": "lsmarch.html#loading-coast-shapefile",
    "href": "lsmarch.html#loading-coast-shapefile",
    "title": "LandSat 8 March",
    "section": "",
    "text": "Using OSM Data to first extract a coastline of the island\n\n# query osm\ngran_canaria_query = opq(bbox = \"Gran Canaria\") %&gt;%\n  add_osm_feature(key = \"place\", value = \"island\") %&gt;%\n  osmdata_sf()\n# extract the coast data\ngran_canaria_sf = gran_canaria_query$osm_multipolygons\n\n# make spatial vector\ngran_canaria_vect = st_transform(gran_canaria_sf, crs(b2)) %&gt;%\n  vect()"
  },
  {
    "objectID": "lsmarch.html#masking-ocean-values",
    "href": "lsmarch.html#masking-ocean-values",
    "title": "LandSat 8 March",
    "section": "",
    "text": "b2 = mask(b2, gran_canaria_vect)\nb3 = mask(b3, gran_canaria_vect)\nb4 = mask(b4, gran_canaria_vect)\nb5 = mask(b5, gran_canaria_vect)\nb6 = mask(b6, gran_canaria_vect)\nb7 = mask(b7, gran_canaria_vect)\nb10 = mask(b10, gran_canaria_vect)"
  },
  {
    "objectID": "lsmarch.html#calculating-ndvi",
    "href": "lsmarch.html#calculating-ndvi",
    "title": "LandSat 8 March",
    "section": "",
    "text": "Perhaps the most important metric beside LST is NVDI. NDVI is also used in the computation of impassivity and ultimately therefore emissivity adjusted LST.\nTo calculate NDVI, the following formula is used:\n\\[\n\\text{NDVI} = \\frac{\\text{NIR} - \\text{Red}}{\\text{NIR} + \\text{Red}}\n\\]\nHere \\(NIR\\) represents the Near-Infrared band reflectance value, in Landsat 8 this is Band 5. Further \\(Red\\) represents the Red band reflectance value, in Landsat 8 this is Band 4.\n\n# calc and plot ndvi using bands 5 and 4\nndvi = (b5-b4)/(b5+b4)\n\nplot_rast(ndvi,\n          \"Normalised Difference Vegetation Index (NDVI)\",\n          c(\"brown\", \"green\"))"
  },
  {
    "objectID": "lsmarch.html#calculating-ndbi",
    "href": "lsmarch.html#calculating-ndbi",
    "title": "LandSat 8 March",
    "section": "",
    "text": "Another important metric is NDBI as urban artificial surfaces may trap heat causing excess heating relative to vegetated surfaces.\nTo calculate NDBI for Landsat 8, the following formula is used (Abulibdeh 2021):\n\\[\n\\text{NDVI} = \\frac{\\text{MIR} - \\text{NIR}}{\\text{MIR} + \\text{NIR}}\n\\]\nHere \\(NIR\\) again represents the Middle-Infrared band value, in Landsat 8 this is Band 5. Also \\(NIR\\) again represents the Near-Infrared band value, being Landsat 8 Band 5.\nHowever, we may not use this as for arid areas it has reduced efficacy. Instead we may rasterise OSM building data.\n\nndbi = (b6-b5)/(b6+b5)\n\nplot_rast(ndbi,\n          \"Normalised Difference Built Index (NDBI)\",\n          c(\"lightgreen\", \"black\"))"
  },
  {
    "objectID": "lsmarch.html#calculating-ndwi",
    "href": "lsmarch.html#calculating-ndwi",
    "title": "LandSat 8 March",
    "section": "",
    "text": "Complementing these metrics is NDWI, here used to analyse the impact that surface water has upon the temperature.\nTo calculate NWBI for Landsat 8, the following formula is used:\n\\[\n\\text{NDVI} = \\frac{\\text{Green} - \\text{SWIR}}{\\text{Green} + \\text{SWIR}}\n\\]\nHere \\(Green\\) represents the Green reflectance values, in Landsat 8 this is Band 3. Also \\(SWIR\\) again represents the Short-Infrared band value, being Landsat 8 Band 7.\n\n# calc and plot\nndwi = (b3-b7)/(b3+b7)\n\nplot_rast(ndwi,\n          \"Normalised Difference Water Index (NDWI)\",\n          c(\"yellow\", \"blue\"))"
  },
  {
    "objectID": "lsmarch.html#calculating-surface-albedo",
    "href": "lsmarch.html#calculating-surface-albedo",
    "title": "LandSat 8 March",
    "section": "",
    "text": "There is also surface albedo \\(\\alpha\\), which is the the fraction of the reflected shortwave radiation, is calculated using the following formula (Equere et al. 2021):\n\\[\n\\alpha = \\frac{0.356·\\text{Blue} + 0.0130 · \\text{Red} + 0.373 · \\text{NIR} + 0.085 * \\text{MIR} + 0.072 · \\text{SWIR} - 0.0018}{1.016}\n\\]\nHere \\(Blue\\) represents the Blue reflectance values, in Landsat 8 this is Band 2. \\(Red\\) again represents the Red band value, being Landsat 8 Band 4. \\(NIR\\) represents the Near-Infrared values, in Landsat 8 this is Band 5. \\(MIR\\) likewise represents the Middle-Infrared values, being Landsat 8 Band 6. Finally \\(SWIR\\) represents the Near-Infrared values, in Landsat 8 this is Band 7.\n\n# calc and plot\nalbedo = (0.356*b2+0.0130*b4+0.373*b5+0.085*b6+0.072*b7-0.0018)/1.016\n\nplot_rast(albedo,\n          expression(paste(\"Surface Albedo (\", alpha,\")\")),\n          c(\"pink\", \"blue\"))"
  },
  {
    "objectID": "lsmarch.html#calculating-lst",
    "href": "lsmarch.html#calculating-lst",
    "title": "LandSat 8 March",
    "section": "",
    "text": "Calculating LST can be straightforward in principle, using Band 10 alone of Landsat 8 data. However, this will not account for surface emissivity. Thus, for this study, an adjusted LST is calculated.\n\n\nThe first step is to convert the Digital Numbers \\(DN\\) in the Band 10 layer to Top of Atmosphere Spectral Radiance \\(L_\\lambda\\) values. This process uses input units found the images metadata/MLT file. These values are the RADIANCE_MULT_BAND_10 \\(M_L\\) and the RADIANCE_ADD_BAND_10 \\(\\text{A}_L\\).\nPutting these together into a formula is as follows:\n\\[\n\\text{L}_\\lambda = \\text{M}_L · \\text{DN} + \\text{A}_L\n\\]\n\n# define metadata values\nmult_b10 = 3.8e-04\nadd_b10 = 0.1\n\n# calc and plot\nl = (mult_b10*b10+add_b10)\n\nplot_rast(l,\n          expression(Spectral~Radiance~(L[lambda])),\n          c(\"brown\", \"yellow\"))\n\n\n\n\n\n\n\nThe second step is “Conversion of Radiance to At-Sensor Temperature” (Karyati et al. 2022). This This converts the Spectral Radiance into temperature values or Brightness Temperature \\(BT\\) in Kelvin. This process requires two constants related to Landsat 8 Band 10’s specific thermal conversion constants found again in the metadata file. These are \\(K1\\)and \\(K2\\).\nPutting this together into a formula is as follows:\n\\[\n\\text{BT} = \\frac{\\text{K2}}{ln(\\frac{\\text{K1}}{\\text{L}_\\lambda} + 1)}\n\\]\n\n# add effective wavelength of landsat b10\nk1 = 799.0284\nk2 = 1329.2405\n\n# calc and plot\nbt = (k2/log(k1/l+1))\n\nplot_rast(bt,\n          expression(Brightness~Temp~(BT)),\n          c(\"blue\", \"red\")) \n\n\n\n\n\n\n\nThe above metric alone could be used for study of heat distribution, however it does not account for the variation caused by surface level emissivity. Emissivity denotes how much infrared a surface will absorb or reflect, ranging from a mirror to a perfect black surface. The values of emissivity range from 0 to 1 respectively.\n\n\nNDVI is used to determine emissivity, through the fractional vegetation factor \\(\\text{P}_v\\). This value is specific to the region being studied.\nThe formula for calculating fractional vegetation factor is as follows:\n\\[\n\\text{P}_v = \\left( \\frac{\\text{NDVI} - \\text{NDVI}_{\\min}}{\\text{NDVI}_{\\max} - \\text{NDVI}_{\\min}} \\right)^2\n\\]\n\n# define min and max ndvi\nmin_ndvi = global(ndvi, fun=min, na.rm=TRUE) %&gt;%\n  as.numeric()\nmax_ndvi = global(ndvi, fun=max, na.rm=TRUE) %&gt;%\n  as.numeric()\n\n# calc and plot vegetation factor\npv = ((ndvi-min_ndvi)/(max_ndvi-min_ndvi))^2\n\nplot_rast(pv,\n          expression(Fractional~Vegetation~Factor~(P[v])),\n          c(\"maroon\", \"green\"))\n\n\n\n\n\n\n\nFrom this the surface emissivity can be calculated. This uses two constants relating to the relative emissivity of soil \\(\\epsilon\\text{s}\\lambda\\) and the emissivity of vegetation \\(\\epsilon\\text{v}\\lambda\\), as well as one surface roughness \\(\\text{C}\\lambda\\) metric of 0.005\nThe formula for estimating emissivity \\(\\epsilon\\lambda\\) is thus as follows:\n\\[\n\\epsilon\\lambda = \\epsilon\\text{v}\\lambda + \\epsilon\\text{s}\\lambda  · (1 - \\text{P}_v) + \\text{C}\\lambda\n\\]\n\n# soil emissivity\nes = 0.964\n\n# veg emissivity\nev = 0.984\n\n# calc and plot emissivity\ne =  ev*pv+es*(1-pv)+0.005\n\nplot_rast(e,\n          expression(Emissivity~(epsilon*lambda)),\n          c(\"yellow\", \"darkgreen\"))\n\n\n\n\n\n\n\n\nNow most of the building blocks are in place to calculate the adjusted LST. This requires a correction constant \\(\\rho\\) that incorporates the Speed of Light \\(c\\), Planck’s constant \\(h\\), and Boltzmann’s constant \\(\\sigma\\).\nThe formula for this is as follows:\n\\[\n\\rho = \\frac{c·h}{\\sigma}\n\\]\n\n# speed of light\nc = 2.997925e8 \n\n# planck's constant\nh = 6.626070e-34\n\n# boltzmann's constant\nsigma = 1.380649e-23\n\n# calc and output correction constant/rho \nrho = c*h/sigma\nrho\n\n[1] 0.01438777\n\n\n\n\n\nWith these building blocks, plus the wavelength of the emitted radiance for Landsat 8 \\(\\lambda\\), the adjusted LST \\(\\text{T}s\\) can be determined using the following formula (converting from Kelvin to Celcius:\n\\[\n\\text{T}_s = \\frac{\\text{BT}}{1 + (\\frac{\\lambda\\text{BT}}{\\rho} · ln(\\epsilon\\lambda))} - 273.15\n\\]\n\n# wavelength\nwl = 10.895e-6\n\n# calc and plot\nts = bt/(1+(wl*bt/rho)*log(e))-273.15\n\nplot_rast(ts,\n          expression(Land~Surface~Temperature~(T[s])), c(\"blue\", \"red\"))\n\n\n\n\n\n\nUsing the Leaflet Package for R (Cheng et al. 2023), we can visualise the resulting rast\n\nplet(ts,\n     col=(c(\"darkblue\",\"pink\")),\n     legend=\"bottomright\",\n     main=\"LST (Cº)\",\n     tiles=c(\"Esri.WorldImagery\"))"
  },
  {
    "objectID": "lsmarch.html#stack-and-export",
    "href": "lsmarch.html#stack-and-export",
    "title": "LandSat 8 March",
    "section": "",
    "text": "stack = c(ndvi, ndbi, ndwi, albedo, ts)\n\ndata_df = na.omit(as.data.frame(stack, xy=TRUE))\n\ndata_df$month = \"march\"\n\nnames(data_df) = c(\"X\", \"Y\", \n                   \"NDVI\",\"NDBI\",\n                   \"NDWI\", \"Albedo\", \"TS\",\n                   \"Month\")\n\nwrite_csv(data_df, \"march.csv\")"
  },
  {
    "objectID": "modelling.html",
    "href": "modelling.html",
    "title": "LandSat 8, TS, & Modelling",
    "section": "",
    "text": "Here I train a variety of models predicting and understanding TS using LandSat 8 at 30m resolution. This is in a similar process to Onačillová et al. (2022); Son et al. (2017); Karyati et al. (2022). In this modelling process we employ two families of modelling approaches:\n\nLinear Regression (Onačillová et al. 2022)\n\n\n# load packages\nlibrary(tidyverse)\nlibrary(terra)\nlibrary(RColorBrewer)\nlibrary(sf)\nlibrary(leaflet)\nlibrary(osmdata)\nlibrary(modelsummary)\nlibrary(ggnewscale)\nlibrary(nnet)\nlibrary(car)"
  },
  {
    "objectID": "modelling.html#general-linear-models",
    "href": "modelling.html#general-linear-models",
    "title": "LandSat 8, TS, & Modelling",
    "section": "General Linear Models",
    "text": "General Linear Models\nThe first GLM model is simply multivariate linear regression fitted within a OLS framework.\n\nFitting the Model\nThe formula for this model is:\nWhere \\(i\\) denotes the individual 30m raster tiles and \\(\\epsilon\\) denotes the residual error not accounted for.\nAlso, there is analysis of a potential interaction effect between tourism and building exposure, as the types of built up area may vary as we move from a tourism heavy area, thus also adding the following term to the OLS function.\nI also make a fixed effect model with weights for the month.\n\n# compute models\nmodel_ols1 = lm(TS ~ \n                 TourismExposure +\n                 BuildingExposure +\n                 Albedo +\n                 NDVI +\n                 NDWI +\n                 CoastDistance +\n                 Elevation,\n               data = mean_data)\nsummary(model_ols1)\n\n\nCall:\nlm(formula = TS ~ TourismExposure + BuildingExposure + Albedo + \n    NDVI + NDWI + CoastDistance + Elevation, data = mean_data)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-7.7329 -0.6938  0.1266  0.8557  4.7132 \n\nCoefficients:\n                   Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)       3.722e+01  7.715e-02 482.403   &lt;2e-16 ***\nTourismExposure  -2.028e-01  9.634e-03 -21.046   &lt;2e-16 ***\nBuildingExposure -5.013e-01  9.529e-03 -52.605   &lt;2e-16 ***\nAlbedo            1.351e-04  6.713e-06  20.126   &lt;2e-16 ***\nNDVI             -8.624e+00  9.833e-02 -87.696   &lt;2e-16 ***\nNDWI             -1.240e+01  1.474e-01 -84.071   &lt;2e-16 ***\nCoastDistance     6.529e-01  1.043e-02  62.593   &lt;2e-16 ***\nElevation        -3.677e-04  2.566e-04  -1.433    0.152    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.296 on 33078 degrees of freedom\nMultiple R-squared:  0.578, Adjusted R-squared:  0.5779 \nF-statistic:  6473 on 7 and 33078 DF,  p-value: &lt; 2.2e-16\n\nvif(model_ols1)\n\n TourismExposure BuildingExposure           Albedo             NDVI \n        1.827350         1.787731         1.172550         1.181254 \n            NDWI    CoastDistance        Elevation \n        1.274859         1.842025         2.030954 \n\npar(mfrow=c(2,2))\nplot(model_ols1)\n\n\n\n# with an interaction term\nmodel_ols2 = lm(TS ~ \n                 TourismExposure * BuildingExposure +\n                 NDVI +\n                 Albedo +\n                 NDWI +\n                 CoastDistance +\n                 Elevation,\n               data = mean_data)\n\nsummary(model_ols2)\n\n\nCall:\nlm(formula = TS ~ TourismExposure * BuildingExposure + NDVI + \n    Albedo + NDWI + CoastDistance + Elevation, data = mean_data)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-7.7926 -0.7000  0.1203  0.8509  4.8558 \n\nCoefficients:\n                                   Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)                       3.722e+01  7.707e-02 482.943  &lt; 2e-16 ***\nTourismExposure                  -2.986e-01  1.471e-02 -20.302  &lt; 2e-16 ***\nBuildingExposure                 -4.828e-01  9.756e-03 -49.485  &lt; 2e-16 ***\nNDVI                             -8.599e+00  9.827e-02 -87.511  &lt; 2e-16 ***\nAlbedo                            1.308e-04  6.725e-06  19.451  &lt; 2e-16 ***\nNDWI                             -1.233e+01  1.475e-01 -83.620  &lt; 2e-16 ***\nCoastDistance                     6.753e-01  1.074e-02  62.883  &lt; 2e-16 ***\nElevation                        -1.078e-03  2.693e-04  -4.004 6.24e-05 ***\nTourismExposure:BuildingExposure  9.435e-02  1.095e-02   8.619  &lt; 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.295 on 33077 degrees of freedom\nMultiple R-squared:  0.579, Adjusted R-squared:  0.5789 \nF-statistic:  5685 on 8 and 33077 DF,  p-value: &lt; 2.2e-16\n\nvif(model_ols2)\n\nthere are higher-order terms (interactions) in this model\nconsider setting type = 'predictor'; see ?vif\n\n\n                 TourismExposure                 BuildingExposure \n                        4.269356                         1.878304 \n                            NDVI                           Albedo \n                        1.182218                         1.179085 \n                            NDWI                    CoastDistance \n                        1.278131                         1.956993 \n                       Elevation TourismExposure:BuildingExposure \n                        2.240954                         2.772837 \n\npar(mfrow=c(2,2))\nplot(model_ols2)\n\n\n\n# define a threshold for high and low tourism exposure\nthreshold = 0\n\n# split the dataset\nhigh_tourism = subset(mean_data, TourismExposure &gt; threshold)\nlow_tourism = subset(mean_data, TourismExposure &lt;= threshold)\n\n# fit separate models for high and low tourism exposure areas\nmodel_high = lm(TS ~ BuildingExposure + Albedo + NDVI + NDWI + CoastDistance + Elevation, data = high_tourism)\nmodel_low = lm(TS ~ BuildingExposure + Albedo + NDVI + NDWI + CoastDistance + Elevation, data = low_tourism)\n\n# compare summaries\nsummary(model_high)\n\n\nCall:\nlm(formula = TS ~ BuildingExposure + Albedo + NDVI + NDWI + CoastDistance + \n    Elevation, data = high_tourism)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-7.2660 -0.7750  0.0152  0.7544  4.3550 \n\nCoefficients:\n                   Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)       3.739e+01  1.316e-01 284.059  &lt; 2e-16 ***\nBuildingExposure -7.169e-01  2.257e-02 -31.764  &lt; 2e-16 ***\nAlbedo            3.881e-05  1.167e-05   3.327 0.000882 ***\nNDVI             -7.310e+00  2.031e-01 -35.987  &lt; 2e-16 ***\nNDWI             -1.004e+01  2.556e-01 -39.285  &lt; 2e-16 ***\nCoastDistance     6.503e-01  1.973e-02  32.955  &lt; 2e-16 ***\nElevation         2.437e-02  1.339e-03  18.197  &lt; 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.367 on 9662 degrees of freedom\nMultiple R-squared:  0.3917,    Adjusted R-squared:  0.3913 \nF-statistic:  1037 on 6 and 9662 DF,  p-value: &lt; 2.2e-16\n\nsummary(model_low)\n\n\nCall:\nlm(formula = TS ~ BuildingExposure + Albedo + NDVI + NDWI + CoastDistance + \n    Elevation, data = low_tourism)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-7.6435 -0.6557  0.1552  0.8414  3.8209 \n\nCoefficients:\n                   Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)       3.715e+01  9.529e-02 389.795  &lt; 2e-16 ***\nBuildingExposure -4.508e-01  1.128e-02 -39.979  &lt; 2e-16 ***\nAlbedo            1.617e-04  8.221e-06  19.669  &lt; 2e-16 ***\nNDVI             -8.798e+00  1.124e-01 -78.274  &lt; 2e-16 ***\nNDWI             -1.332e+01  1.799e-01 -74.025  &lt; 2e-16 ***\nCoastDistance     6.047e-01  1.271e-02  47.558  &lt; 2e-16 ***\nElevation        -1.004e-03  2.773e-04  -3.619 0.000296 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.241 on 23410 degrees of freedom\nMultiple R-squared:  0.4911,    Adjusted R-squared:  0.491 \nF-statistic:  3766 on 6 and 23410 DF,  p-value: &lt; 2.2e-16\n\n\n\n\nPlot Fit Key Linear Models\n\nscatterplot = all_density_plot = ggplot() +\n  geom_point(data = mean_data,\n             aes(x = BuildingExposure,\n                 y = TS,\n                 colour = TourismExposure), \n             alpha = 0.03) +\n  scale_color_viridis_b() +\n  labs(title = \"Effects of Building Concentration on Land Surface Temperature\",\n       subtitle = \"All Building Concentrations,\nMaspalomas/Playa del Inglés region of Gran Canaria\",\n       caption = \"Model Based on LandSat Imagery from 2023\",\n       x = \"Building Concentration Index\",\n       y = \"Land Surface Temperature ºC\")\nscatterplot\n\n\n\n\n\n# all building concentrations \ntourism_dense = tibble(\n  NDVI = mean(high_tourism$NDVI),\n  BuildingExposure = seq(min(high_tourism$BuildingExposure),\n                         max(high_tourism$BuildingExposure),\n                         by = 0.05),\n  Albedo = mean(high_tourism$Albedo),\n  NDWI = mean(high_tourism$NDWI),\n  CoastDistance = mean(high_tourism$CoastDistance),\n  Elevation = mean(high_tourism$Elevation)\n)\n\ntourism_sparse = tibble(\n  NDVI = mean(low_tourism$NDVI),\n  BuildingExposure = seq(min(low_tourism$BuildingExposure),\n                         max(low_tourism$BuildingExposure),\n                         by = 0.05),\n  Albedo = mean(low_tourism$Albedo),\n  NDWI = mean(low_tourism$NDWI),\n  CoastDistance = mean(low_tourism$CoastDistance),\n  Elevation = mean(low_tourism$Elevation)\n)\n\n# predict values\ntourism_dense_predictions = predict(\n  model_high,\n  newdata = tourism_dense,\n  se.fit = TRUE,\n  interval = \"confidence\"\n) %&gt;% \n  as.data.frame() %&gt;%\n  bind_cols(tourism_dense) %&gt;%\n  select(c(\"fit.fit\", \"fit.lwr\", \"fit.upr\", \"BuildingExposure\"))\ntourism_dense_predictions$area = \"High Tourism\"\n\ntourism_sparse_predictions = predict(\n  model_low,\n  newdata = tourism_sparse,\n  se.fit = TRUE,\n  interval = \"confidence\"\n) %&gt;% \n  as.data.frame() %&gt;%\n  bind_cols(tourism_sparse) %&gt;%\n  select(c(\"fit.fit\", \"fit.lwr\", \"fit.upr\", \"BuildingExposure\"))\ntourism_sparse_predictions$area = \"Low Tourism\"\n\n# bind into toplot\ntoplot = rbind(tourism_dense_predictions,\n               tourism_sparse_predictions)\n\n# comparison plot\n\nall_density_plot = ggplot() +\n  geom_line(data = toplot,\n            aes(x = BuildingExposure,\n                y = fit.fit,\n                colour = area),\n            alpha = 2) +\n  scale_colour_manual(values = c(\"Low Tourism\" = \"blue\", \"High Tourism\" = \"red\"),\n                      name = \"Area Type\") +\n  geom_point(data = high_tourism,\n             aes(x = BuildingExposure,\n                 y = TS),\n             colour = \"pink\",\n             alpha = 0.03) +\n  geom_point(data = low_tourism,\n             aes(x = BuildingExposure,\n                 y = TS),\n             colour = \"lightblue\",\n             alpha = 0.03) +\n  labs(title = \"Effects of Building Concentration on Land Surface Temperature\",\n       subtitle = \"All Building Concentrations,\nMaspalomas/Playa del Inglés region of Gran Canaria\",\n       caption = \"Model Based on LandSat Imagery from 2023\",\n       x = \"Building Concentration Index\",\n       y = \"Predicted Land Surface Temperature ºC\")\n\nall_density_plot"
  },
  {
    "objectID": "modelling.html#polynominal-interaction-modeling",
    "href": "modelling.html#polynominal-interaction-modeling",
    "title": "LandSat 8, TS, & Modelling",
    "section": "Polynominal Interaction Modeling",
    "text": "Polynominal Interaction Modeling\n\nmodel_poly_interaction = lm(TS ~ \n                             BuildingExposure + I(BuildingExposure^2) +\n                             TourismExposure + I(TourismExposure^2) +\n                             Albedo + NDVI + NDWI +\n                             CoastDistance + Elevation +\n                             BuildingExposure:TourismExposure +\n                             BuildingExposure:Albedo +\n                             BuildingExposure:NDVI +\n                             BuildingExposure:NDWI +\n                             TourismExposure:Albedo +\n                             TourismExposure:NDVI +\n                             TourismExposure:NDWI,\n                           data = mean_data)\n\n# Summary of the polynomial model with interactions\nsummary(model_poly_interaction)\n\n\nCall:\nlm(formula = TS ~ BuildingExposure + I(BuildingExposure^2) + \n    TourismExposure + I(TourismExposure^2) + Albedo + NDVI + \n    NDWI + CoastDistance + Elevation + BuildingExposure:TourismExposure + \n    BuildingExposure:Albedo + BuildingExposure:NDVI + BuildingExposure:NDWI + \n    TourismExposure:Albedo + TourismExposure:NDVI + TourismExposure:NDWI, \n    data = mean_data)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-7.0379 -0.6840  0.0702  0.7838  5.1192 \n\nCoefficients:\n                                   Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)                       3.698e+01  7.572e-02 488.309  &lt; 2e-16 ***\nBuildingExposure                  2.127e+00  9.814e-02  21.668  &lt; 2e-16 ***\nI(BuildingExposure^2)             1.079e-01  1.190e-02   9.073  &lt; 2e-16 ***\nTourismExposure                  -7.018e-01  9.170e-02  -7.653 2.02e-14 ***\nI(TourismExposure^2)              1.077e-01  7.852e-03  13.723  &lt; 2e-16 ***\nAlbedo                            1.369e-04  6.534e-06  20.954  &lt; 2e-16 ***\nNDVI                             -8.358e+00  9.970e-02 -83.827  &lt; 2e-16 ***\nNDWI                             -1.255e+01  1.436e-01 -87.387  &lt; 2e-16 ***\nCoastDistance                     7.095e-01  1.093e-02  64.905  &lt; 2e-16 ***\nElevation                        -3.263e-03  2.657e-04 -12.283  &lt; 2e-16 ***\nBuildingExposure:TourismExposure -4.985e-02  1.395e-02  -3.573 0.000354 ***\nBuildingExposure:Albedo          -2.067e-04  8.196e-06 -25.221  &lt; 2e-16 ***\nBuildingExposure:NDVI             2.949e-01  1.719e-01   1.716 0.086199 .  \nBuildingExposure:NDWI             6.659e+00  1.782e-01  37.359  &lt; 2e-16 ***\nTourismExposure:Albedo            1.806e-05  7.638e-06   2.364 0.018071 *  \nTourismExposure:NDVI              5.301e-01  1.569e-01   3.378 0.000730 ***\nTourismExposure:NDWI             -1.481e+00  1.670e-01  -8.865  &lt; 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.231 on 33069 degrees of freedom\nMultiple R-squared:  0.6199,    Adjusted R-squared:  0.6197 \nF-statistic:  3370 on 16 and 33069 DF,  p-value: &lt; 2.2e-16\n\n\n\n# all building concentrations, polynominal \ntourism_area = tibble(\n  TourismExposure = 3,\n  NDVI = mean(total_data$NDVI),\n  BuildingExposure = seq(min(total_data$BuildingExposure),\n                         max(total_data$BuildingExposure),\n                         by = 0.05),\n  Albedo = mean(total_data$Albedo),\n  NDWI = mean(total_data$NDWI),\n  CoastDistance = mean(total_data$CoastDistance),\n  Elevation = mean(total_data$Elevation)\n)\n\nresidence_area = tibble(\n  TourismExposure = -0.6,\n  NDVI = mean(total_data$NDVI),\n  BuildingExposure = seq(min(total_data$BuildingExposure),\n                         max(total_data$BuildingExposure),\n                         by = 0.05),\n  Albedo = mean(total_data$Albedo),\n  NDWI = mean(total_data$NDWI),\n  CoastDistance = mean(total_data$CoastDistance),\n  Elevation = mean(total_data$Elevation)\n)\n\n# bind together\nscenario = rbind(tourism_area, residence_area)\n\n# predict values\narea_predictions = predict(\n  model_poly_interaction,\n  newdata = scenario,\n  se.fit = TRUE,\n  interval = \"confidence\"\n)\n\n# make tibble\narea_predictions = area_predictions$fit %&gt;% \n  as_tibble()\n\n# make toplot\ntoplot = bind_cols(scenario,\n                   area_predictions)\n\ntoplot = select(toplot, c(\"fit\", \"lwr\", \"upr\",\n                          \"BuildingExposure\",\n                          \"TourismExposure\"))\n\ntoplot$area = ifelse(toplot$TourismExposure == -0.6, \"Residence\",\n                     \"Tourist\")\n\n# plot polynominals\n\npoly_density_plot_lines = ggplot(data = toplot,\n                                 aes(x = BuildingExposure,\n                                     y = fit,\n                                     ymin = lwr,\n                                     ymax = upr,\n                                     fill = area)) +\n  geom_line(alpha = 2) +\n  geom_ribbon(alpha = 0.5) +\n  scale_fill_manual(values = c(\"Residence\" = \"blue\", \"Tourist\" = \"red\"),\n                      name = \"Area Type\") +\n  labs(title = \"Effects of Building Concentration on Land Surface Temperature\",\n       subtitle = \"All Building Concentrations,\nMaspalomas/Playa del Inglés region of Gran Canaria\",\n       caption = \"Model Based on LandSat Imagery from 2023\",\n       x = \"Building Concentration Index\",\n       y = \"Land Surface Temperature ºC\")\n\npoly_density_plot_points = ggplot() +\n  geom_line(data = toplot,\n            aes(x = BuildingExposure,\n                y = fit,\n                colour = area),\n            alpha = 2) +\n  scale_colour_manual(values = c(\"Residence\" = \"blue\", \"Tourist\" = \"red\"),\n                      name = \"Area Type\") +\n  new_scale_color() +\n  geom_point(data = mean_data,\n             aes(x = BuildingExposure,\n                 y = TS,\n                 colour = TourismExposure),\n             alpha = 0.02) +\n  scale_color_viridis_c(name = \"Tourism Concentration\") +\n  labs(title = \"Effects of Building Concentration on Land Surface Temperature\",\n       subtitle = \"All Building Concentrations,\nMaspalomas/Playa del Inglés region of Gran Canaria\",\n       caption = \"Model Based on LandSat Imagery from 2023\",\n       x = \"Building Concentration Index\",\n       y = \"Land Surface Temperature ºC\")\n\npoly_density_plot_lines\n\n\n\npoly_density_plot_points"
  }
]